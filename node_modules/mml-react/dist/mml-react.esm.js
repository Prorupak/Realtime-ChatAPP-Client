import React, { Children, cloneElement, useState, useCallback, useRef, useEffect, useMemo } from 'react';
import parseXml from '@rgrove/parse-xml';
import dayjs from 'dayjs';
import { sanitizeUrl } from '@braintree/sanitize-url';
import ReactMarkdown from 'react-markdown';
import { find } from 'linkifyjs';
import IcalExpander from 'ical-expander';
import { Virtuoso } from 'react-virtuoso';
import isBetween from 'dayjs/plugin/isBetween';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

function isXmlElement(node) {
  return !!node.children;
}
/**
 * MMLTag - Xml tag converted to this MMLTag
 */


var MMLTag = /*#__PURE__*/function () {
  function MMLTag(name, node, children) {
    this.name = name;
    this.node = node;
    this.attributes = this.node.attributes || {};
    this.children = children;
  }

  var _proto = MMLTag.prototype;

  _proto.getText = function getText() {
    if (this.node.type === 'text') return this.node.text;else if (isXmlElement(this.node) && this.node.children.length) return this.node.children[0].text;
    return '';
  };

  _proto.initialState = function initialState() {
    var _ref;

    var _this$attributes = this.attributes,
        name = _this$attributes.name,
        value = _this$attributes.value;
    if (name) return _ref = {}, _ref[name] = value, _ref;
    return {};
  };

  return MMLTag;
}();

var Card = function Card(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      children = _ref.children;
  return React.createElement("div", {
    className: "mml-card " + className
  }, children);
};

var Icon = function Icon(_ref) {
  var name = _ref.name;
  return React.createElement("i", {
    className: "mml-icon material-icons"
  }, name);
};

var CardHeader = function CardHeader(_ref) {
  var text = _ref.text,
      _ref$icon = _ref.icon,
      icon = _ref$icon === void 0 ? '' : _ref$icon,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return React.createElement("div", {
    className: "mml-card-header " + className
  }, icon && React.createElement(Icon, {
    name: icon
  }), React.createElement("span", {
    className: "mml-card-header__text"
  }, text));
};

var CardBody = function CardBody(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      children = _ref.children;
  return React.createElement("div", {
    className: "mml-card-body " + className
  }, children);
};

/**
 * A list of buttons
 */

var ButtonList = function ButtonList(_ref) {
  var children = _ref.children,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? '' : _ref$variant;
  return React.createElement("div", {
    className: "mml-btnlist " + (variant === 'floating' ? ' mml-btnlist--floating' : 'mml-btnlist--grounded')
  }, children);
};

/**
 * Utility to have custom svg icons outside the `material-icons` system provided by the Icon component
 * Use case internal to this library is the AddToCalendar component which needs brand icons which are not
 * included in [the default material-icons set and probably never will be](https://git.io/Jk9yH)
 */

var SvgIcon = function SvgIcon(_ref) {
  var path = _ref.path;
  return React.createElement("i", {
    className: "mml-icon"
  }, React.createElement("svg", {
    className: "mml-icon__svg",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, React.createElement("path", {
    d: path
  })));
};
/** Icon path from https://materialdesignicons.com/ */


var IconGoogle = /*#__PURE__*/React.createElement(SvgIcon, {
  path: "M21.35 11.1h-9.17v2.73h6.5c-.33 3.8-3.5 5.44-6.5 5.44C8.36 19.27 5 16.25 5 12c0-4.1 3.2-7.27 7.2-7.27 3.1 0 4.9 1.97 4.9 1.97L19 4.72S16.56 2 12.1 2C6.42 2 2.03 6.8 2.03 12c0 5.05 4.13 10 10.22 10 5.35 0 9.25-3.67 9.25-9.1 0-1.15-.15-1.8-.15-1.8h0z"
});
/** Icon path from https://materialdesignicons.com/ */

var IconMicrosoft = /*#__PURE__*/React.createElement(SvgIcon, {
  path: "M3 12V6.75l6-1.32v6.48L3 12m17-9v8.75l-10 .15V5.2L20 3M3 13l6 .1v6.8l-6-1.15V13m17 .25V22l-10-1.9v-7l10 .15z"
});
/** Icon path from https://materialdesignicons.com/ */

var IconApple = /*#__PURE__*/React.createElement(SvgIcon, {
  path: "M18.7 19.5c-.83 1.24-1.7 2.45-3.05 2.47-1.34.03-1.77-.8-3.3-.8-1.53 0-2 .77-3.27.82-1.3.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.4c.87-1.52 2.43-2.48 4.12-2.5 1.28-.02 2.5.87 3.3.87.78 0 2.26-1.07 3.8-.9.65.03 2.47.26 3.64 1.98-.1.06-2.17 1.28-2.15 3.8.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.2-.7.85-1.83 1.5-2.95 1.42-.15-1.15.4-2.35 1.05-3.1z"
});

function isMobile() {
  var ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';
  if (!ua) return false;
  var mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
  if (mobileRE.test(ua)) return true;
  if (typeof navigator !== 'undefined' && navigator.maxTouchPoints > 1 && ua.indexOf('Macintosh') !== -1 && ua.indexOf('Safari') !== -1) return true;
  return false;
} // @ts-ignore (expect-error breaks in GH actions) TODO: replace deprecated method


var isIE = typeof window !== 'undefined' && window.navigator.msSaveOrOpenBlob && window.Blob;

var getCurrentURL = function getCurrentURL() {
  if (typeof window !== 'undefined') return window.location.href;
  return '';
};

var CALENDAR_SERVICES = [{
  id: 'google',
  label: 'Google',
  Icon: IconGoogle
}, {
  id: 'apple',
  label: 'Apple Calendar',
  Icon: IconApple
}, {
  id: 'outlook',
  label: 'Outlook',
  Icon: IconMicrosoft
}, {
  id: 'outlookcom',
  label: 'Outlook.com',
  Icon: IconMicrosoft
}];
/**
 * Format time
 *
 * Adapted from the `moment` way of [react-add-to-calendar](https://git.io/JkWol)
 * to the dayjs way
 */

function formatTime(date, id) {
  return dayjs(date).format(id === 'outlookcom' ? 'YYYY-MM-DDTHH:mm:ss' : 'YYYYMMDDTHHmmss') + 'Z';
}
/**
 * Create query string with given parameters
 *
 * It checks that the parameter value is not falsy
 */


function createQueryString(params) {
  if (params === void 0) {
    params = {};
  }

  return Object.keys(params).reduce(function (acc, key) {
    var value = params[key];
    if (value) acc += "&" + key + "=" + encodeURIComponent(value);
    return acc;
  }, '');
}
/**
 * Build calendar URL
 *
 * Resources:
 * - [SO question about Google](https://stackoverflow.com/q/22757908)
 * - [docs about outlook.com format](https://git.io/JkWp5)
 * - [addevent wrapper SaaS](https://www.addevent.com/)
 */


function buildUrl(event, id) {
  var start = event.start,
      end = event.end,
      title = event.title,
      location = event.location,
      description = event.description;
  var startFormatted = formatTime(start, id);
  var endFormatted = formatTime(end, id);
  if (id === 'google') return "https://calendar.google.com/calendar/render?action=TEMPLATE&dates=" + startFormatted + "/" + endFormatted + createQueryString({
    location: location,
    text: title,
    details: description
  });
  if (id === 'outlookcom') return "https://outlook.live.com/owa/?rru=addevent" + createQueryString({
    startdt: startFormatted,
    enddt: endFormatted,
    subject: title,
    location: location,
    body: description,
    allday: 'false'
  }) + "&path=/calendar/view/Month";
  var url = ['BEGIN:VCALENDAR', 'VERSION:2.0', 'BEGIN:VEVENT', 'URL:' + getCurrentURL(), 'DTSTART:' + startFormatted, 'DTEND:' + endFormatted, 'SUMMARY:' + title, 'DESCRIPTION:' + description, 'LOCATION:' + location, 'END:VEVENT', 'END:VCALENDAR'].join('\n');
  if (!isIE && isMobile()) url = encodeURI('data:text/calendar;charset=utf8,' + url);
  return url;
}
/**
 * AddToCalendar widget that supports google, apple and outlook calendars
 */


var AddToCalendar = function AddToCalendar(_ref2) {
  var title = _ref2.title,
      start = _ref2.start,
      end = _ref2.end,
      _ref2$className = _ref2.className,
      className = _ref2$className === void 0 ? '' : _ref2$className,
      _ref2$location = _ref2.location,
      location = _ref2$location === void 0 ? '' : _ref2$location,
      _ref2$description = _ref2.description,
      description = _ref2$description === void 0 ? '' : _ref2$description;
  var event = {
    start: start,
    end: end,
    title: title,
    location: location,
    description: description
  };

  function handleLinkClick(event) {
    event.preventDefault();
    var url = event.currentTarget.getAttribute('href');

    if (!isMobile() && (url.startsWith('data') || url.startsWith('BEGIN'))) {
      var filename = 'download.ics';
      var blob = new Blob([url], {
        type: 'text/calendar;charset=utf-8'
      });

      if (isIE) {
        // @ts-ignore (expect-error breaks in GH actions) TODO: replace deprecated method
        window.navigator.msSaveOrOpenBlob(blob, filename);
      } else {
        // many browsers do not properly support downloading data URIs
        // (even with "download" attribute in use) so this solution
        // ensures the event will download cross-browser
        var link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.setAttribute('download', filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    } else {
      window.open(url, '_blank');
    }
  }

  return React.createElement(Card, {
    className: "mml-add-to-calendar " + className
  }, React.createElement(CardHeader, {
    icon: "date_range",
    text: "Add to My Calendar"
  }), React.createElement(CardBody, null, React.createElement(ButtonList, null, CALENDAR_SERVICES.map(function (_ref3) {
    var id = _ref3.id,
        label = _ref3.label,
        Icon = _ref3.Icon;
    return React.createElement("a", {
      key: id,
      className: "mml-btn " + (Icon ? 'mml-btn--with-icon' : ''),
      onClick: handleLinkClick,
      href: buildUrl(event, id),
      target: "_blank",
      rel: "nofollow noreferrer noopener"
    }, Icon, " ", label);
  }))));
};

/**
 * Button can be used to open a URL, submit the form or trigger a select when clicked
 */

var Button = function Button(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      text = _ref.text,
      name = _ref.name,
      value = _ref.value,
      _ref$url = _ref.url,
      url = _ref$url === void 0 ? '' : _ref$url,
      variant = _ref.variant,
      icon = _ref.icon;

  if (icon) {
    className += text ? ' mml-btn--with-icon' : ' mml-btn--icon';
  } else {
    className += ' mml-btn--text';
  }

  className += variant === 'floating' ? ' mml-btn--floating' : ' mml-btn--grounded';
  if (url) return React.createElement("a", {
    className: "mml-btn " + className,
    href: sanitizeUrl(url),
    target: "_blank",
    rel: "nofollow noreferrer noopener"
  }, icon && React.createElement(Icon, {
    name: icon
  }), text);
  return React.createElement("button", {
    className: "mml-btn " + className,
    type: "submit",
    name: name,
    value: value,
    onClick: function onClick(event) {
      var _event$currentTarget, _event$currentTarget$;

      var input = document.createElement('input');
      input.type = 'hidden';
      input.name = name || '';
      input.value = value || '';
      (_event$currentTarget = event.currentTarget) == null ? void 0 : (_event$currentTarget$ = _event$currentTarget.closest('form')) == null ? void 0 : _event$currentTarget$.appendChild(input);
    }
  }, icon && React.createElement(Icon, {
    name: icon
  }), text);
};

/**
 * A carousel is a nice mobile friendly way of letting a user select something
 *
 * Super simple scroll based carousel slightly inspired by [react-scroll-snap-slider](https://github.com/lifarl/react-scroll-snap-slider)
 */

var Carousel = function Carousel(_ref) {
  var children = _ref.children,
      _ref$slideWidth = _ref.slideWidth,
      slideWidth = _ref$slideWidth === void 0 ? '120px' : _ref$slideWidth,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return React.createElement("div", {
    className: "mml-carousel " + className
  }, React.createElement("div", {
    className: "mml-carousel__track"
  }, React.createElement("div", {
    className: "mml-carousel__slides"
  }, Children.map(children, function (child) {
    return cloneElement(child, {
      className: 'mml-carousel__slide',
      slideWidth: slideWidth
    });
  }))));
};

/**
 * A carousel item
 */

var CarouselItem = function CarouselItem(_ref) {
  var children = _ref.children,
      slideWidth = _ref.slideWidth,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? '' : _ref$width,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  var finalWidth = width || slideWidth;
  return React.createElement("div", {
    className: "mml-carousel-item " + className,
    style: {
      flex: "0 0 " + finalWidth,
      minWidth: finalWidth
    }
  }, children);
};

/**
 * A grid column
 * TODO: Consider renaming this element
 */

var Col = function Col(_ref) {
  var children = _ref.children,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? 12 : _ref$width,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? 0 : _ref$offset,
      _ref$align = _ref.align,
      align = _ref$align === void 0 ? 'left' : _ref$align;
  var classNames = "mml-col-" + width;
  if (offset) classNames = classNames + (" mml-offset-" + offset);
  classNames = classNames + (" mml-align-" + align);
  return React.createElement("div", {
    className: classNames
  }, children);
};

var Error$1 = function Error(_ref) {
  var _ref$error = _ref.error,
      error = _ref$error === void 0 ? '' : _ref$error;
  if (!error) return null;
  return React.createElement("span", {
    className: "mml-error"
  }, error);
};

var Image = function Image(_ref) {
  var src = _ref.src,
      _ref$alt = _ref.alt,
      alt = _ref$alt === void 0 ? '' : _ref$alt,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? '' : _ref$title,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return React.createElement("img", {
    className: ("mml-image " + className).trim(),
    src: src,
    alt: alt,
    title: title
  });
};

/**
 * Text input element. Usually you'll want to rely on regular messages
 */

var Input = function Input(_ref) {
  var name = _ref.name,
      label = _ref.label,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'text' : _ref$type,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder;

  var _useState = useState(value),
      state = _useState[0],
      setState = _useState[1];

  var id = "mml-" + name;
  return React.createElement(React.Fragment, null, label && React.createElement("label", {
    className: "mml-card-header",
    htmlFor: id
  }, React.createElement("span", {
    className: "mml-card-header__text"
  }, label)), React.createElement("input", {
    id: id,
    className: "mml-input",
    name: name,
    value: state,
    type: type,
    placeholder: placeholder,
    onChange: function onChange(event) {
      return setState(event.target.value);
    }
  }));
};

var SIZE = 44;
var Progress = function Progress(_ref) {
  var size = _ref.size,
      _ref$thickness = _ref.thickness,
      thickness = _ref$thickness === void 0 ? 3.6 : _ref$thickness,
      color = _ref.color;
  thickness = typeof thickness === 'string' ? parseFloat(thickness) : thickness; // interpret a digit only string or a number as a pixel value otherwise leave
  // it as astring, it might be a value like `2em` or `120%`

  size = typeof size === 'string' && /^\d+$/.test(size) || typeof size === 'number' ? size + 'px' : size;
  return React.createElement("span", {
    className: "mml-progress",
    role: "progressbar",
    style: {
      width: size,
      height: size,
      color: color
    }
  }, React.createElement("svg", {
    className: "mml-progress__svg",
    viewBox: SIZE / 2 + " " + SIZE / 2 + " " + SIZE + " " + SIZE
  }, React.createElement("circle", {
    className: "mml-progress__circle",
    cx: SIZE,
    cy: SIZE,
    r: (SIZE - thickness) / 2,
    fill: "none",
    strokeWidth: thickness
  })));
};

/**
 * Loading indicator
 */

var Loading = function Loading(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$loading = _ref.loading,
      loading = _ref$loading === void 0 ? false : _ref$loading,
      text = _ref.text,
      size = _ref.size,
      thickness = _ref.thickness,
      color = _ref.color;
  if (!loading) return null;
  return React.createElement("div", {
    className: "mml-loading " + className
  }, React.createElement(Progress, Object.assign({}, {
    size: size,
    thickness: thickness,
    color: color
  })), text && React.createElement("div", {
    className: "mml-loading__text"
  }, text));
};

var truncate = function truncate(input, length, end) {
  if (end === void 0) {
    end = '...';
  }

  if (input.length > length) return "" + input.substring(0, length - end.length) + end;
  return input;
};

var matchMarkdownLinks = function matchMarkdownLinks(message) {
  var regexMdLinks = /\[([^[]+)\](\(.*\))/gm;
  var matches = message.match(regexMdLinks);
  var singleMatch = /\[([^[]+)\]\((.*)\)/;
  var links = matches ? matches.map(function (match) {
    var i = singleMatch.exec(match);
    return i && i[2];
  }) : [];
  return links;
};

var MDLinkRender = function MDLinkRender(props) {
  if (!props.href || !props.href.startsWith('http') && !props.href.startsWith('mailto:')) return props.children;
  return React.createElement("a", {
    href: props.href,
    target: "_blank",
    rel: "nofollow noreferrer noopener"
  }, props.children);
};

var markDownRenderers = {
  link: MDLinkRender
};
var allowedMarkups = ['html', // @ts-ignore
'root', 'text', 'break', 'paragraph', 'emphasis', 'strong', 'link', 'list', 'listItem', 'code', 'inlineCode', 'blockquote'];
/**
 * MD renders a given text as markdown
 */

var MD = function MD(_ref) {
  var text = _ref.text;
  if (!text) return null;
  var newText = text;
  var markdownLinks = matchMarkdownLinks(newText); // extract all valid links/emails within text and replace it with proper markup

  find(newText).forEach(function (_ref2) {
    var type = _ref2.type,
        href = _ref2.href,
        value = _ref2.value;
    // check if message is already  markdown
    var noParsingNeeded = markdownLinks && markdownLinks.filter(function (text) {
      return (text == null ? void 0 : text.indexOf(href)) !== -1;
    });
    if (noParsingNeeded.length > 0) return;
    var displayLink = type === 'email' ? value : truncate(value.replace(/(http(s?):\/\/)?(www\.)?/, ''), 20);
    newText = newText.replace(value, "[" + displayLink + "](" + encodeURI(href) + ")");
  });
  return React.createElement("div", {
    className: "mml-md"
  }, React.createElement(ReactMarkdown, {
    allowedTypes: allowedMarkups,
    renderers: markDownRenderers,
    source: newText,
    escapeHtml: true,
    unwrapDisallowed: true,
    transformLinkUri: function transformLinkUri(uri) {
      return uri.startsWith('app://') ? uri : ReactMarkdown.uriTransformer(uri);
    }
  }));
};

/**
 * Mobile friendly number input
 */

var Number = function Number(_ref) {
  var name = _ref.name,
      value = _ref.value;

  var _useState = useState(parseInt("" + value, 10) || 0),
      state = _useState[0],
      setState = _useState[1];

  return React.createElement("div", {
    className: "mml-number"
  }, React.createElement("input", {
    name: name,
    value: state,
    type: "hidden"
  }), React.createElement("span", {
    className: "mml-btn mml-btn--floating mml-btn--icon mml-number__dec",
    onClick: function onClick() {
      return setState(state - 1);
    }
  }, React.createElement(Icon, {
    name: "remove"
  })), React.createElement("span", {
    className: "mml-number__count"
  }, state), React.createElement("span", {
    className: "mml-btn mml-btn--floating mml-btn--icon mml-number__inc",
    onClick: function onClick() {
      return setState(state + 1);
    }
  }, React.createElement(Icon, {
    name: "add"
  })));
};

var Row = function Row(_ref) {
  var children = _ref.children;
  return React.createElement("div", {
    className: "mml-row"
  }, children);
};

var ITEMS_PER_PAGE = 40;
var VERTICAL_COMPENSATION = 3;
var INITIAL_INDEX = ITEMS_PER_PAGE;
var VIRTUOSO_START_INDEX = 10000;
/**
 * DatePicker select
 */

var DatePickerSelect = function DatePickerSelect(props) {
  var onChange = props.onChange,
      icalFilter = props.icalFilter,
      getItemData = props.getItemData,
      itemClassName = props.itemClassName,
      interval = props.interval,
      format = props.format,
      value = props.value; // Generate date items

  var generateItems = useCallback(function (quantity, firstIdx) {
    return Array(quantity).fill(true).map(function (_, idx) {
      return getItemData({
        interval: interval,
        format: format,
        value: value,
        idx: firstIdx + idx
      });
    }).filter(function (newItem) {
      return !icalFilter || icalFilter && icalFilter(newItem.value);
    });
  }, [interval, format, value, icalFilter, getItemData]);

  var _useState = useState(generateItems(ITEMS_PER_PAGE * 2, -ITEMS_PER_PAGE)),
      items = _useState[0],
      setItems = _useState[1];

  var _useState2 = useState(VIRTUOSO_START_INDEX),
      firstItemIndex = _useState2[0],
      setFirstItemIndex = _useState2[1];

  var initialIndexOffset = useRef(INITIAL_INDEX);

  var _useState3 = useState(null),
      selectedIdx = _useState3[0],
      setSelectedIdx = _useState3[1];

  var handleClick = useCallback(function (item) {
    onChange(item.value);
    var firstItemIndex = initialIndexOffset.current || 0;
    var nextFirstItemIdx = firstItemIndex - INITIAL_INDEX - ITEMS_PER_PAGE;
    var missingTopItems = nextFirstItemIdx - item.idx + VERTICAL_COMPENSATION; // prepend date items, when the selected date's index is too low we prepend
    // some date options so that it will remain vertically centered in the middle

    if (missingTopItems >= 0) {
      nextFirstItemIdx -= missingTopItems;
      initialIndexOffset.current -= firstItemIndex - missingTopItems;
      setItems(function (items) {
        return [].concat(generateItems(missingTopItems, nextFirstItemIdx), items);
      });
    }

    setSelectedIdx(item.idx);
  }, [setItems, generateItems, initialIndexOffset, onChange]);
  var appendItems = useCallback(function (lastItemIndex) {
    setItems(function (items) {
      return [].concat(items, generateItems(ITEMS_PER_PAGE, lastItemIndex));
    });
  }, [setItems, generateItems]); // @see https://git.io/JIUuo

  var prependItems = useCallback(function () {
    var firstItemIndex = initialIndexOffset.current || 0;
    var nextFirstItemIdx = firstItemIndex - INITIAL_INDEX - ITEMS_PER_PAGE;

    if (initialIndexOffset) {
      initialIndexOffset.current -= ITEMS_PER_PAGE;
    }

    setItems(function (items) {
      return [].concat(generateItems(ITEMS_PER_PAGE, nextFirstItemIdx), items);
    });
    setFirstItemIndex(firstItemIndex - ITEMS_PER_PAGE);
    return false;
  }, [setItems, generateItems, initialIndexOffset]); // on mount check if there is a selected value and save its idx in state

  useEffect(function () {
    if (value) {
      var initialSelectedIdx = null;

      for (var i = 0; i < items.length; i++) {
        if (items[i].isSelected(value)) {
          initialSelectedIdx = items[i].idx;
          break;
        }
      }

      setSelectedIdx(initialSelectedIdx);
    }
  }, []); // eslint-disable-line

  return React.createElement(Virtuoso, {
    data: items,
    firstItemIndex: firstItemIndex,
    itemContent: function itemContent(_, item) {
      return React.createElement("div", {
        className: itemClassName + (" mml-datepicker__item " + (item.idx === selectedIdx ? 'mml-datepicker__item--selected' : '')),
        onClick: function onClick() {
          return handleClick(item);
        }
      }, item.displayValue);
    },
    endReached: appendItems,
    startReached: prependItems
  });
};

/**
 * Get item data
 */

var getItemData = function getItemData(props) {
  var idx = props.idx,
      interval = props.interval,
      value = props.value,
      format = props.format;
  var newValue = idx >= 0 ? dayjs(value).add(idx * (interval * 24), 'hour') : dayjs(value).subtract(idx * (interval * 24) * -1, 'hour');
  return {
    idx: idx,
    value: newValue,
    displayValue: dayjs(newValue).format(format),
    isSelected: function isSelected(currentValue) {
      return dayjs(newValue).isSame(interval === 1 ? dayjs(currentValue) : dayjs(currentValue).add(interval, 'day'), 'date');
    }
  };
};
/**
 * DatePicker date
 */


var DatePickerDate = function DatePickerDate(props) {
  return React.createElement("div", {
    className: "mml-datepicker__select mml-datepicker__date"
  }, React.createElement(DatePickerSelect, Object.assign({}, props, {
    itemClassName: "mml-datepicker__item--day",
    getItemData: getItemData
  })));
};

dayjs.extend(isBetween);
/**
 * Get item data
 */

var getItemData$1 = function getItemData(props) {
  var idx = props.idx,
      interval = props.interval,
      value = props.value,
      format = props.format;
  var newValue = idx >= 0 ? dayjs(value).add(idx * interval, 'minute') : dayjs(value).subtract(idx * -1 * interval, 'minute');
  return {
    idx: idx,
    value: newValue,
    displayValue: dayjs(newValue).format(format),
    isSelected: function isSelected(currentValue) {
      return dayjs(newValue).isBetween(currentValue, dayjs(currentValue).add(interval - 1, 'minute'), 'minute', '[]');
    }
  };
};
/**
 * DatePicker time
 */


var DatePickerTime = function DatePickerTime(props) {
  return React.createElement("div", {
    className: "mml-datepicker__select mml-datepicker__time"
  }, React.createElement(DatePickerSelect, Object.assign({}, props, {
    itemClassName: "mml-datepicker__item--time",
    getItemData: getItemData$1
  })));
};

var DatePicker = function DatePicker(_ref) {
  var name = _ref.name,
      selected = _ref.selected,
      dateInterval = _ref.dateInterval,
      timeInterval = _ref.timeInterval,
      dateFormat = _ref.dateFormat,
      timeFormat = _ref.timeFormat,
      fullDay = _ref.fullDay,
      icalFilter = _ref.icalFilter;

  var _useState = useState(selected),
      date = _useState[0],
      setDate = _useState[1];

  var handleChangeDate = function handleChangeDate(value) {
    setDate(function (prevDate) {
      return prevDate.set('date', value.get('date')).set('month', value.get('month')).set('year', value.get('year'));
    });
  };

  var handleChangeTime = function handleChangeTime(value) {
    setDate(function (prevDate) {
      return prevDate.set('minute', value.get('minute')).set('hour', value.get('hour'));
    });
  };

  return React.createElement("div", {
    className: "mml-datepicker mml-datepicker--" + (fullDay ? 'single' : 'double')
  }, React.createElement("input", {
    name: name,
    value: date.toISOString(),
    type: "hidden"
  }), React.createElement(DatePickerDate, {
    icalFilter: icalFilter,
    format: dateFormat,
    value: date,
    onChange: handleChangeDate,
    interval: dateInterval
  }), !fullDay && React.createElement(DatePickerTime, {
    icalFilter: icalFilter,
    format: timeFormat,
    value: date,
    onChange: handleChangeTime,
    interval: timeInterval
  }));
};

var setupIcalFilter = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(icalURL, duration) {
    var response, body, icalExpander;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch(icalURL, {
              method: 'GET',
              redirect: 'follow',
              credentials: 'same-origin'
            });

          case 2:
            response = _context.sent;
            _context.next = 5;
            return response.text();

          case 5:
            body = _context.sent;

            if (response.ok) {
              _context.next = 8;
              break;
            }

            throw new Error(body);

          case 8:
            icalExpander = new IcalExpander({
              ics: body,
              maxIterations: 10
            });
            return _context.abrupt("return", function () {
              return function (start) {
                if (!start) return true;

                var _icalExpander$between = icalExpander.between(start.toDate(), start.add(duration, 'minute').toDate()),
                    events = _icalExpander$between.events;

                return !events.length;
              };
            });

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function setupIcalFilter(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var Scheduler = function Scheduler(_ref2) {
  var name = _ref2.name,
      selected = _ref2.selected,
      icalAvailability = _ref2.icalAvailability,
      _ref2$duration = _ref2.duration,
      duration = _ref2$duration === void 0 ? 30 : _ref2$duration,
      _ref2$dateInterval = _ref2.dateInterval,
      dateInterval = _ref2$dateInterval === void 0 ? 1 : _ref2$dateInterval,
      _ref2$timeInterval = _ref2.timeInterval,
      timeInterval = _ref2$timeInterval === void 0 ? 30 : _ref2$timeInterval,
      _ref2$dateFormat = _ref2.dateFormat,
      dateFormat = _ref2$dateFormat === void 0 ? 'ddd MMM DD' : _ref2$dateFormat,
      _ref2$timeFormat = _ref2.timeFormat,
      timeFormat = _ref2$timeFormat === void 0 ? 'hh:mm A' : _ref2$timeFormat,
      _ref2$fullDay = _ref2.fullDay,
      fullDay = _ref2$fullDay === void 0 ? false : _ref2$fullDay;

  var _useState = useState(false),
      loading = _useState[0],
      setLoading = _useState[1];

  var _useState2 = useState(''),
      error = _useState2[0],
      setError = _useState2[1];

  var _useState3 = useState(function () {
    return function () {
      return true;
    };
  }),
      icalFilter = _useState3[0],
      setIcalFilter = _useState3[1];

  useEffect(function () {
    if (!icalAvailability) return;
    setLoading(true);
    setupIcalFilter(icalAvailability, duration).then(setIcalFilter)["catch"](function (err) {
      console.warn('loading ical failed', {
        icalAvailability: icalAvailability,
        err: err
      });
      setError('iCal availability could not be loaded');
    })["finally"](function () {
      return setLoading(false);
    });
  }, [icalAvailability, duration]);
  return React.createElement(Card, {
    className: "mml-scheduler"
  }, React.createElement(CardHeader, {
    icon: "date_range",
    text: "Scheduler"
  }), React.createElement(CardBody, null, error && !loading && React.createElement(Error$1, {
    error: "Failed, error: " + error
  }), !error && loading && React.createElement(Loading, {
    loading: true,
    text: "Loading availability"
  }), !error && !loading && React.createElement(DatePicker, {
    name: name,
    selected: selected ? dayjs(selected) : dayjs().startOf('hour'),
    dateInterval: dateInterval,
    timeInterval: timeInterval,
    dateFormat: dateFormat,
    timeFormat: timeFormat,
    fullDay: fullDay,
    icalFilter: icalFilter
  })));
};

var Success = function Success(_ref) {
  var success = _ref.success;
  if (success) return React.createElement("div", {
    className: "mml-success"
  }, success);
  return null;
};

/**
 * Simple paragraph text element
 */

var Text = function Text(_ref) {
  var text = _ref.text,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;
  return React.createElement("div", {
    className: ("mml-text " + className).trim()
  }, text);
};

/**
 * The converters maps MML tags to react nodes
 * Every converter is passed the MML tag as well as the children (as React nodes)
 */

var converters = {
  button: function button(tag) {
    return React.createElement(Button, Object.assign({}, tag.attributes, {
      key: tag.key,
      text: tag.getText(),
      name: tag.attributes.name,
      value: tag.attributes.value
    }));
  },
  button_list: function button_list(tag, children) {
    return React.createElement(ButtonList, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  input: function input(tag) {
    return React.createElement(Input, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name,
      value: tag.attributes.value
    }));
  },
  add_to_calendar: function add_to_calendar(tag) {
    return React.createElement(AddToCalendar, Object.assign({}, tag.attributes, {
      key: tag.key,
      title: tag.attributes.title,
      start: tag.attributes.start,
      end: tag.attributes.end
    }));
  },
  col: function col(tag, children) {
    return React.createElement(Col, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  row: function row(tag, children) {
    return React.createElement(Row, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  icon: function icon(tag) {
    return React.createElement(Icon, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name
    }));
  },
  image: function image(tag) {
    return React.createElement(Image, Object.assign({}, tag.attributes, {
      key: tag.key,
      src: tag.attributes.src
    }));
  },
  md: function md(tag) {
    return React.createElement(MD, Object.assign({}, tag.attributes, {
      key: tag.key,
      text: tag.getText()
    }));
  },
  text: function text(tag) {
    return React.createElement(Text, Object.assign({}, tag.attributes, {
      key: tag.key,
      text: tag.getText()
    }));
  },
  scheduler: function scheduler(tag) {
    return React.createElement(Scheduler, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name,
      dateInterval: parseInt(tag.attributes.dateInterval, 10) || 1,
      timeInterval: parseInt(tag.attributes.timeInterval, 10) || 30,
      duration: parseInt(tag.attributes.duration, 10) || 30,
      selected: tag.attributes.selected,
      fullDay: tag.attributes.fullDay === 'true',
      icalAvailability: tag.attributes.icalAvailability
    }));
  },
  carousel: function carousel(tag, children) {
    return React.createElement(Carousel, Object.assign({
      slideWidth: tag.attributes.slideWidth
    }, tag.attributes, {
      key: tag.key
    }), children);
  },
  item: function item(tag, children) {
    return React.createElement(CarouselItem, Object.assign({}, tag.attributes, {
      key: tag.key
    }), children);
  },
  number: function number(tag) {
    return React.createElement(Number, Object.assign({}, tag.attributes, {
      key: tag.key,
      name: tag.attributes.name,
      value: tag.attributes.value
    }));
  }
};

/**
 * Tree - The tree object for MML tags
 */

var Tree = /*#__PURE__*/function () {
  function Tree(node, children, customConvertors) {
    this.converters = _extends({}, converters, customConvertors);
    this.node = node;
    this.children = children;
    this.reactElements = this.toReact();
    this.name = node.attributes.name;
    this.type = node.attributes.type;
  }
  /**
   * convert all nodes to react and maintain the hierarchy
   */


  var _proto = Tree.prototype;

  _proto.toReact = function toReact(parent) {
    var _this = this;

    if (parent === void 0) {
      parent = this;
    }

    var reactNodes = [];
    (parent.children || []).forEach(function (child, i) {
      var converter = _this.converters[child.name];

      if (!converter || !Object.hasOwnProperty.call(_this.converters, child.name)) {
        throw Error("Converter not found for tag " + child.name + ", Available converters are " + Object.keys(_this.converters));
      }

      var children = _this.toReact(child);

      child.key = "tag-" + child.name + "-position-" + i;
      reactNodes.push(converter(child, children));
    });
    return reactNodes;
  };

  return Tree;
}();

/**
 * SourceToXML - Takes an MML string and converts it to XML nodes
 *
 * @param {string} source MML tag string
 *
 * @returns {array} an Array of XML nodes
 */

function SourceToXML(source) {
  var src = source.trim(); // the wrapping MML tags are optional, for parsing simplicity we automatically add them if they are not already there

  if (!src.startsWith('<mml')) src = "<mml>" + source + "</mml>"; // emulate HTML handling of & escaping

  var unescapedAmps = /&(?!amp;|lt;|gt;)/g;
  src = src.replace(unescapedAmps, '&amp;'); // convert the string to XML nodes
  // this library is relatively lightweight and doesn't do a ton of validation

  return parseXml(src);
}

function convertNodes(nodes) {
  return nodes.reduce(function (acc, node) {
    var element = node;
    var children;
    if (element.children) children = convertNodes(element.children);
    var name = element.name;

    if (node.type === 'text') {
      if (node.text.trim().length) name = 'text';else return acc; // skip empty text elements
    }

    acc.push(new MMLTag(name, node, children));
    return acc;
  }, []);
}
/**
 * XMLtoMMLTree - Takes an array of XML nodes and converts it into an MML Tree
 *
 * @param {type} XMLNodes an array of XML nodes
 *
 * @returns {MMLTree} The MML tree
 */


function XMLtoMMLTree(document, customConvertors) {
  if (!document || !document.children || !document.children.length) throw new Error('bad input');
  var mmlNode = document.children[0];
  if (mmlNode.name !== 'mml') throw new Error('missing mml tag');
  return new Tree(mmlNode, convertNodes(mmlNode.children), customConvertors);
}
/**
 * Takes an MML string and returns an MML Tree
 *
 * @param {string} source MML tag string
 *
 *  @returns {Tree} An MML Tree
 */

function Parse(source, customConvertors) {
  var XMLNodes = SourceToXML(source);
  return XMLtoMMLTree(XMLNodes, customConvertors);
}

/**
 * MML root component
 */

var MML = function MML(_ref) {
  var source = _ref.source,
      onSubmit = _ref.onSubmit,
      converters = _ref.converters,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? '' : _ref$theme,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$Loading = _ref.Loading,
      Loading$1 = _ref$Loading === void 0 ? Loading : _ref$Loading,
      _ref$Error = _ref.Error,
      Error = _ref$Error === void 0 ? Error$1 : _ref$Error,
      _ref$Success = _ref.Success,
      Success$1 = _ref$Success === void 0 ? Success : _ref$Success;

  var _useState = useState(''),
      error = _useState[0],
      setError = _useState[1];

  var _useState2 = useState({
    loading: false,
    error: '',
    success: ''
  }),
      submitState = _useState2[0],
      setSubmitState = _useState2[1];

  var tree = useMemo(function () {
    try {
      return Parse(source, converters);
    } catch (e) {
      console.warn('mml parsing error: ', source, e);
      setError("This chat message has invalid formatting and can't be shown");
      return null;
    }
  }, [source, converters]);
  var handleSubmit = useCallback( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(event) {
      var state;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              event.preventDefault();
              state = {};
              if (tree != null && tree.name) state.mml_name = tree.name; // include mml_name in the data

              new FormData(event.currentTarget).forEach(function (value, key) {
                state[key] = value;
              });

              if (onSubmit) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", console.warn('Forgot to pass onSubmit prop to <MML/>? payload:', state));

            case 6:
              _context.prev = 6;
              setSubmitState({
                loading: true,
                error: '',
                success: ''
              });
              _context.next = 10;
              return onSubmit(state);

            case 10:
              setSubmitState({
                loading: false,
                error: '',
                success: 'submitted'
              });
              _context.next = 16;
              break;

            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](6);
              setSubmitState({
                loading: false,
                error: 'Failed to send the request. Please try again.',
                success: ''
              });

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[6, 13]]);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), [onSubmit, tree]);
  return React.createElement("div", {
    className: "mml-container " + theme + " " + className,
    "data-testid": "mml-container"
  }, error ? React.createElement("div", {
    className: "mml-wrap"
  }, Error && React.createElement(Error, {
    error: error
  })) : React.createElement("form", {
    onSubmit: handleSubmit,
    className: "mml-wrap",
    "data-testid": "mml-form"
  }, tree != null && tree.type ? React.createElement("div", {
    className: "mml-card"
  }, tree == null ? void 0 : tree.reactElements) : tree == null ? void 0 : tree.reactElements, submitState.loading && Loading$1 && React.createElement(Loading$1, {
    loading: submitState.loading
  }), submitState.success && Success$1 && React.createElement(Success$1, {
    success: submitState.success
  }), submitState.error && Error && React.createElement(Error, {
    error: submitState.error
  })));
};

export { AddToCalendar, Button, ButtonList, Card, CardBody, CardHeader, Carousel, CarouselItem, Col, Error$1 as Error, Icon, Image, Input, Loading, MD, MML, MMLTag, Number, Parse, Row, Scheduler, SourceToXML, Success, Text, Tree, XMLtoMMLTree, converters, truncate };
//# sourceMappingURL=mml-react.esm.js.map
