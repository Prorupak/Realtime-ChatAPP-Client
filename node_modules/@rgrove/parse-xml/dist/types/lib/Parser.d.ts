export = Parser;
/**
Parses an XML string into an `XmlDocument`.

@private
*/
declare class Parser {
    /**
    @param {string} xml
      XML string to parse.
  
    @param {object} [options]
      Parsing options.
  
      @param {boolean} [options.ignoreUndefinedEntities=false]
      @param {boolean} [options.preserveCdata=false]
      @param {boolean} [options.preserveComments=false]
      @param {(entity: string) => string?} [options.resolveUndefinedEntity]
      @param {boolean} [options.sortAttributes=false]
    */
    constructor(xml: string, options?: {
        ignoreUndefinedEntities?: boolean | undefined;
        preserveCdata?: boolean | undefined;
        preserveComments?: boolean | undefined;
        resolveUndefinedEntity?: ((entity: string) => string | null) | undefined;
        sortAttributes?: boolean | undefined;
    } | undefined);
    /** @type {XmlDocument} */
    document: XmlDocument;
    /** @type {XmlDocument|XmlElement} */
    currentNode: XmlDocument | XmlElement;
    options: {
        ignoreUndefinedEntities?: boolean | undefined;
        preserveCdata?: boolean | undefined;
        preserveComments?: boolean | undefined;
        resolveUndefinedEntity?: ((entity: string) => string | null) | undefined;
        sortAttributes?: boolean | undefined;
    };
    scanner: StringScanner;
    /**
    Adds the given `XmlNode` as a child of `this.currentNode`.
  
    @param {XmlNode} node
    */
    addNode(node: XmlNode): void;
    /**
    Adds the given _text_ to the document, either by appending it to a preceding
    `XmlText` node (if possible) or by creating a new `XmlText` node.
  
    @param {string} text
    */
    addText(text: string): void;
    /**
    Consumes an `AttValue` (attribute value) if possible.
  
    @returns {string|false}
      Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.
      An empty string indicates that an `AttValue` was consumed but was empty.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue
    */
    consumeAttributeValue(): string | false;
    /**
    Consumes a CDATA section if possible.
  
    @returns {boolean}
      Whether a CDATA section was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect
    */
    consumeCdataSection(): boolean;
    /**
    Consumes character data if possible.
  
    @returns {boolean}
      Whether character data was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata
    */
    consumeCharData(): boolean;
    /**
    Consumes a comment if possible.
  
    @returns {boolean}
      Whether a comment was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment
    */
    consumeComment(): boolean;
    /**
    Consumes a reference in a content context if possible.
  
    This differs from `consumeReference()` in that a consumed reference will be
    added to the document as a text node instead of returned.
  
    @returns {boolean}
      Whether a reference was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc
    */
    consumeContentReference(): boolean;
    /**
    Consumes a doctype declaration if possible.
  
    This is a loose implementation since doctype declarations are currently
    discarded without further parsing.
  
    @returns {boolean}
      Whether a doctype declaration was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd
    */
    consumeDoctypeDeclaration(): boolean;
    /**
    Consumes an element if possible.
  
    @returns {boolean}
      Whether an element was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element
    */
    consumeElement(): boolean;
    /**
    Consumes an `Eq` production if possible.
  
    @returns {boolean}
      Whether an `Eq` production was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq
    */
    consumeEqual(): boolean;
    /**
    Consumes `Misc` content if possible.
  
    @returns {boolean}
      Whether anything was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc
    */
    consumeMisc(): boolean;
    /**
    Consumes one or more `Name` characters if possible.
  
    @returns {string}
      `Name` characters, or an empty string if none were consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
    */
    consumeName(): string;
    /**
    Consumes a processing instruction if possible.
  
    @returns {boolean}
      Whether a processing instruction was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi
    */
    consumeProcessingInstruction(): boolean;
    /**
    Consumes a prolog if possible.
  
    @returns {boolean}
      Whether a prolog was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd
    */
    consumeProlog(): boolean;
    /**
    Consumes a reference if possible.
  
    This differs from `consumeContentReference()` in that a consumed reference
    will be returned rather than added to the document.
  
    @returns {string|false}
      Parsed reference value, or `false` if nothing was consumed (to distinguish
      from a reference that resolves to an empty string).
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference
    */
    consumeReference(): string | false;
    /**
    Consumes a `SystemLiteral` if possible.
  
    A `SystemLiteral` is similar to an attribute value, but allows the characters
    `<` and `&` and doesn't replace references.
  
    @returns {string|false}
      Value of the `SystemLiteral` minus quotes, or `false` if nothing was
      consumed. An empty string indicates that a `SystemLiteral` was consumed but
      was empty.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral
    */
    consumeSystemLiteral(): string | false;
    /**
    Consumes one or more whitespace characters if possible.
  
    @returns {boolean}
      Whether any whitespace characters were consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#white
    */
    consumeWhitespace(): boolean;
    /**
    Consumes an XML declaration if possible.
  
    @returns {boolean}
      Whether an XML declaration was consumed.
  
    @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl
    */
    consumeXmlDeclaration(): boolean;
    /**
    Throws an error at the current scanner position.
  
    @param {string} message
    */
    error(message: string): void;
    /**
    Throws an invalid character error if any character in the given _string_ isn't
    a valid XML character.
  
    @param {string} string
    */
    validateChars(string: string): void;
}
declare namespace Parser {
    export { XmlNode };
}
import XmlDocument = require("./XmlDocument");
import XmlElement = require("./XmlElement");
import StringScanner = require("./StringScanner");
type XmlNode = import("./XmlNode");
//# sourceMappingURL=Parser.d.ts.map