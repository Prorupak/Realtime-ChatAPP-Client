export = StringScanner;
/**
@private
*/
declare class StringScanner {
    /**
    @param {string} string
    */
    constructor(string: string);
    /** @type {string[]} */
    chars: string[];
    /** @type {number} */
    charCount: number;
    /** @type {number} */
    charIndex: number;
    /** @type {number[]} */
    charsToBytes: number[];
    /** @type {boolean} */
    multiByteMode: boolean;
    /** @type {string} */
    string: string;
    /**
    Whether the current character index is at the end of the input string.
  
    @type {boolean}
    */
    get isEnd(): boolean;
    /**
    Returns the number of characters in the given _string_, which may differ from
    the byte length if the string contains multibyte characters.
  
    @param {string} string
    @returns {number}
    */
    _charLength(string: string): number;
    /**
    Advances the scanner by the given number of characters, stopping if the end of
    the string is reached.
  
    @param {number} [count]
    */
    advance(count?: number | undefined): void;
    /**
    Consumes and returns the given number of characters if possible, advancing the
    scanner and stopping if the end of the string is reached.
  
    If no characters could be consumed, an empty string will be returned.
  
    @param {number} [count]
    @returns {string}
    */
    consume(count?: number | undefined): string;
    /**
    Consumes a match for the given sticky regex, advances the scanner, updates the
    `lastIndex` property of the regex, and returns the matching string.
  
    The regex must have a sticky flag ("y") so that its `lastIndex` prop can be
    used to anchor the match at the current scanner position.
  
    Returns the consumed string, or an empty string if nothing was consumed.
  
    @param {RegExp} regex
    @returns {string}
    */
    consumeMatch(regex: RegExp): string;
    /**
    Consumes and returns all characters for which the given function returns a
    truthy value, stopping on the first falsy return value or if the end of the
    input is reached.
  
    @param {(char: string) => boolean} fn
    @returns {string}
    */
    consumeMatchFn(fn: (char: string) => boolean): string;
    /**
    Consumes the given string if it exists at the current character index, and
    advances the scanner.
  
    If the given string doesn't exist at the current character index, an empty
    string will be returned and the scanner will not be advanced.
  
    @param {string} stringToConsume
    @returns {string}
    */
    consumeString(stringToConsume: string): string;
    /**
     * Does the same thing as `consumeString()`, but doesn't support consuming
     * multibyte characters. This can be much faster if you only need to match
     * single byte characters.
     *
     * @param {string} stringToConsume
     * @returns {string}
     */
    consumeStringFast(stringToConsume: string): string;
    /**
    Consumes characters until the given global regex is matched, advancing the
    scanner up to (but not beyond) the beginning of the match and updating the
    `lastIndex` property of the regex.
  
    The regex must have a global flag ("g") so that its `lastIndex` prop can be
    used to begin the search at the current scanner position.
  
    Returns the consumed string, or an empty string if nothing was consumed.
  
    @param {RegExp} regex
    @returns {string}
    */
    consumeUntilMatch(regex: RegExp): string;
    /**
    Consumes characters until the given string is found, advancing the scanner up
    to (but not beyond) that point.
  
    Returns the consumed string, or an empty string if nothing was consumed.
  
    @param {string} searchString
    @returns {string}
    */
    consumeUntilString(searchString: string): string;
    /**
    Returns the given number of characters starting at the current character
    index, without advancing the scanner and without exceeding the end of the
    input string.
  
    @param {number} [count]
    @returns {string}
    */
    peek(count?: number | undefined): string;
    /**
    Resets the scanner position to the given character _index_, or to the start of
    the input string if no index is given.
  
    If _index_ is negative, the scanner position will be moved backward by that
    many characters, stopping if the beginning of the string is reached.
  
    @param {number} [index]
    */
    reset(index?: number | undefined): void;
}
//# sourceMappingURL=StringScanner.d.ts.map