{"ast":null,"code":"function n(n, r) {\n  return function (t) {\n    return n(r(t));\n  };\n}\n\nfunction r(n, r) {\n  return r(n);\n}\n\nfunction t(n, r) {\n  return function (t) {\n    return n(r, t);\n  };\n}\n\nfunction u(n, r) {\n  return function () {\n    return n(r);\n  };\n}\n\nfunction e(n) {\n  return function (r) {\n    return r[n];\n  };\n}\n\nfunction c(n, r) {\n  return r(n), n;\n}\n\nfunction i() {\n  return [].slice.call(arguments);\n}\n\nfunction o(n) {\n  n();\n}\n\nfunction f(n) {\n  return function () {\n    return n;\n  };\n}\n\nfunction a() {\n  var n = arguments;\n  return function () {\n    [].slice.call(n).map(o);\n  };\n}\n\nfunction l() {}\n\nfunction s(n, r) {\n  return n(1, r);\n}\n\nfunction v(n, r) {\n  n(0, r);\n}\n\nfunction d(n) {\n  n(2);\n}\n\nfunction h(n) {\n  return n(4);\n}\n\nfunction w(n, r) {\n  return s(n, t(r, 0));\n}\n\nfunction p(n, r) {\n  var t = n(1, function (n) {\n    t(), r(n);\n  });\n  return t;\n}\n\nfunction g() {\n  var n = [];\n  return function (r, t) {\n    switch (r) {\n      case 2:\n        return void n.splice(0, n.length);\n\n      case 1:\n        return n.push(t), function () {\n          var r = n.indexOf(t);\n          r > -1 && n.splice(r, 1);\n        };\n\n      case 0:\n        return void n.slice().forEach(function (n) {\n          n(t);\n        });\n\n      default:\n        throw new Error(\"unrecognized action \" + r);\n    }\n  };\n}\n\nfunction E(n) {\n  var r = n,\n      t = g();\n  return function (n, u) {\n    switch (n) {\n      case 1:\n        u(r);\n        break;\n\n      case 0:\n        r = u;\n        break;\n\n      case 4:\n        return r;\n    }\n\n    return t(n, u);\n  };\n}\n\nfunction m(n) {\n  var r,\n      t,\n      u = function u() {\n    return null == r ? void 0 : r();\n  };\n\n  return function (e, c) {\n    switch (e) {\n      case 1:\n        if (null != c) {\n          if (t === c) return;\n          return u(), t = c, r = s(n, c);\n        }\n\n        return u(), l;\n\n      case 2:\n        return u(), void (t = null);\n\n      default:\n        throw new Error(\"unrecognized action \" + e);\n    }\n  };\n}\n\nfunction y(n) {\n  return c(g(), function (r) {\n    return w(n, r);\n  });\n}\n\nfunction z(n, r) {\n  return c(E(r), function (r) {\n    return w(n, r);\n  });\n}\n\nfunction M() {\n  var n = arguments;\n  return function (t) {\n    return [].slice.call(n).reduceRight(r, t);\n  };\n}\n\nfunction b(n) {\n  var r = M.apply(void 0, [].slice.call(arguments, 1));\n  return function (t, u) {\n    switch (t) {\n      case 1:\n        return s(n, r(u));\n\n      case 2:\n        return void d(n);\n\n      default:\n        throw new Error(\"unrecognized action \" + t);\n    }\n  };\n}\n\nfunction k(n, r) {\n  return n === r;\n}\n\nfunction x(n) {\n  var r;\n  return void 0 === n && (n = k), function (t) {\n    return function (u) {\n      n(r, u) || (r = u, t(u));\n    };\n  };\n}\n\nfunction A(n) {\n  return function (r) {\n    return function (t) {\n      n(t) && r(t);\n    };\n  };\n}\n\nfunction T(r) {\n  return function (t) {\n    return n(t, r);\n  };\n}\n\nfunction O(n) {\n  return function (r) {\n    return function () {\n      return r(n);\n    };\n  };\n}\n\nfunction R(n, r) {\n  return function (t) {\n    return function (u) {\n      return t(r = n(r, u));\n    };\n  };\n}\n\nfunction S(n) {\n  return function (r) {\n    return function (t) {\n      n > 0 ? n-- : r(t);\n    };\n  };\n}\n\nfunction j(n) {\n  return function (n) {\n    return function (n) {};\n  };\n}\n\nfunction q(n) {\n  var r, t;\n  return function (u) {\n    return function (e) {\n      r = e, null != t && clearTimeout(t), t = setTimeout(function () {\n        u(r);\n      }, n);\n    };\n  };\n}\n\nfunction B() {\n  var n = [].slice.call(arguments),\n      r = new Array(n.length),\n      t = 0,\n      u = null,\n      e = Math.pow(2, n.length) - 1;\n  return n.forEach(function (n, c) {\n    var i = Math.pow(2, c);\n    s(n, function (n) {\n      var o = t;\n      t |= i, r[c] = n, o !== e && t === e && null != u && (u(), u = null);\n    });\n  }), function (n) {\n    return function (c) {\n      var i = function i() {\n        return n([c].concat(r));\n      };\n\n      t === e ? i() : u = i;\n    };\n  };\n}\n\nfunction C() {\n  var n = [].slice.call(arguments);\n  return function (r, t) {\n    switch (r) {\n      case 1:\n        return a.apply(void 0, n.map(function (n) {\n          return s(n, t);\n        }));\n\n      case 2:\n        return;\n\n      default:\n        throw new Error(\"unrecognized action \" + r);\n    }\n  };\n}\n\nfunction D(n, r) {\n  return void 0 === r && (r = k), b(n, x(r));\n}\n\nfunction F() {\n  var n = [].slice.call(arguments),\n      r = g(),\n      t = new Array(n.length),\n      u = 0,\n      e = Math.pow(2, n.length) - 1;\n  return n.forEach(function (n, c) {\n    var i = Math.pow(2, c);\n    s(n, function (n) {\n      t[c] = n, (u |= i) === e && v(r, t);\n    });\n  }), function (n, c) {\n    switch (n) {\n      case 1:\n        return u === e && c(t), s(r, c);\n\n      case 2:\n        return d(r);\n\n      default:\n        throw new Error(\"unrecognized action \" + n);\n    }\n  };\n}\n\nfunction G(n, r, t) {\n  void 0 === r && (r = []);\n  var u = (void 0 === t ? {\n    singleton: !0\n  } : t).singleton;\n  return {\n    id: H(),\n    constructor: n,\n    dependencies: r,\n    singleton: u\n  };\n}\n\nvar H = function H() {\n  return Symbol();\n};\n\nfunction I(n) {\n  var r = new Map();\n  return function n(t) {\n    var u = t.id,\n        e = t.constructor,\n        c = t.dependencies,\n        i = t.singleton;\n    if (i && r.has(u)) return r.get(u);\n    var o = e(c.map(function (r) {\n      return n(r);\n    }));\n    return i && r.set(u, o), o;\n  }(n);\n}\n\nexport { f as always, o as call, F as combineLatest, n as compose, w as connect, u as curry1to0, t as curry2to1, q as debounceTime, k as defaultComparator, x as distinctUntilChanged, D as duc, m as eventHandler, A as filter, h as getValue, p as handleNext, I as init, a as joinProc, T as map, O as mapTo, C as merge, l as noop, b as pipe, e as prop, v as publish, d as reset, R as scan, S as skip, E as statefulStream, z as statefulStreamFromEmitter, g as stream, y as streamFromEmitter, s as subscribe, G as system, c as tap, j as throttleTime, r as thrush, i as tup, B as withLatestFrom };","map":{"version":3,"sources":["../src/utils.ts","../src/actions.ts","../src/constants.ts","../src/streams.ts","../src/pipe.ts","../src/transformers.ts","../src/system.ts"],"names":["compose","a","b","arg","thrush","proc","curry2to1","arg1","arg2","curry1to0","prop","property","object","tap","tup","call","always","value","joinProc","map","noop","subscribe","emitter","subscription","publish","publisher","reset","getValue","depot","connect","handleNext","unsub","stream","subscriptions","action","splice","length","push","indexOf","slice","forEach","Error","statefulStream","initial","innerSubject","eventHandler","currentSubscription","cleanup","streamFromEmitter","statefulStreamFromEmitter","combineOperators","subscriber","reduceRight","pipe","source","project","defaultComparator","previous","next","distinctUntilChanged","comparator","current","done","filter","predicate","mapTo","scan","scanner","skip","times","throttleTime","interval","debounceTime","currentValue","timeout","clearTimeout","setTimeout","withLatestFrom","sources","values","Array","called","pendingCall","allCalled","Math","pow","index","bit","prevCalled","concat","merge","duc","combineLatest","emitters","system","constructor","dependencies","singleton","id","Symbol","init","systemSpec","singletons","Map","_init","has","get","e","set"],"mappings":"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","sourcesContent":["/**\n * Utils includes\n * - a handful of functional utilities inspired by or taken from the [Ramda library](https://ramdajs.com/);\n * - TypeScript crutches - the [[tup]] function.\n *\n * Use these for your convenience - they are here so that urx is zero-dependency package.\n *\n * @packageDocumentation\n */\n\n/** @internal */\nexport type Proc = () => any\n\n/**\n * Performs left to right composition of two functions.\n */\nexport function compose<I, A, R>(a: (arg: A) => R, b: (arg: I) => A): (arg: I) => R {\n  return (arg: I) => a(b(arg))\n}\n\n/**\n * Takes a value and applies a function to it.\n */\nexport function thrush<I, K>(arg: I, proc: (arg: I) => K) {\n  return proc(arg)\n}\n\n/**\n * Takes a 2 argument function and partially applies the first argument.\n */\nexport function curry2to1<T, K, R>(proc: (arg1: T, arg2: K) => R, arg1: T): (arg2: K) => R {\n  return arg2 => proc(arg1, arg2)\n}\n\n/**\n * Takes a 1 argument function and returns a function which when called, executes it with the provided argument.\n */\nexport function curry1to0<T, R>(proc: (arg: T) => R, arg: T): () => R {\n  return () => proc(arg)\n}\n\n/**\n * Returns a function which extracts the property from from the passed object.\n */\nexport function prop(property: string) {\n  return (object: any) => object[property]\n}\n\n/**\n * Calls callback with the first argument, and returns it.\n */\nexport function tap<T>(arg: T, proc: (arg: T) => any): T {\n  proc(arg)\n  return arg\n}\n\n/**\n *  Utility function to help typescript figure out that what we pass is a tuple and not a generic array.\n *  Taken from (this StackOverflow tread)[https://stackoverflow.com/questions/49729550/implicitly-create-a-tuple-in-typescript/52445008#52445008]\n */\nexport function tup<T extends any[]>(...args: T): T {\n  return args\n}\n\n/**\n * Calls the passed function.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function call(proc: Proc) {\n  proc()\n}\n\n/**\n * returns a function which when called always returns the passed value\n */\nexport function always<T>(value: T) {\n  return () => value\n}\n\n/**\n * returns a function which calls all passed functions in the passed order.\n * joinProc does not pass arguments or collect return values.\n */\nexport function joinProc(...procs: Proc[]) {\n  return () => {\n    procs.map(call)\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function noop() {}\n","/**\n * urx Actions operate on streams - `publish` publishes data in a stream, and `subscribe` attaches a subscription to a stream.\n * @packageDocumentation\n */\nimport { PUBLISH, RESET, SUBSCRIBE, VALUE } from './constants'\nimport { curry2to1 } from './utils'\n\n/**\n * A Publisher is the **input end** of a Stream. The [[publish]] action publishes values in publishers.\n * @typeParam T the type of values to be published.\n */\n/** @internal */\nexport type Publisher<T> = (action: PUBLISH, value: T) => void\n\n/**\n * An Emitter is the **output end** of a Stream. The [[subscribe]] action binds {@link Subscription | subscriptions} to emitters.\n * @typeParam T the type of values that will be emitted.\n */\nexport interface Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE, subscription: Subscription<T>): Unsubscribe\n  /** @internal */\n  (action: RESET): void\n}\n\n/**\n * Subscriptions are bound to Emitters with the [[subscribe]] action, and get called with the new values.\n * @typeParam T the Emitter value type.\n */\nexport type Subscription<T> = (value: T) => any\n\n/**\n * Subscribe-like actions return unsubscribe handles of the Unsubscribe type, which, when called, unbind the subscription.\n */\nexport type Unsubscribe = () => void\n\n/**\n * Streams present both the input and the output ends of a stream.\n * A single stream instance can be both subscribed to and published in.\n */\nexport interface Stream<T> extends Publisher<T>, Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE | PUBLISH | RESET): any // fix for bug with pipe + connect\n}\n\n/**\n * Just like {@link Stream | streams}, stateful streams present both input and output ends of a stream.\n * A single stream instance can be both subscribed to and published in.\n * Stateful Streams can also act like depots, preserving the last passed value and immediately publishing it to new subscriptions.\n * [[getValue]] can be used to extract value from stateful streams.\n */\nexport interface StatefulStream<T> extends Publisher<T>, Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE | PUBLISH | RESET | VALUE): any // fix for bug with pipe + connect\n  // StatefulStream should extend rather then duplicate the signature, but this somehow causes a bug in TS\n}\n\n/**\n * Subscribes the specified [[Subscription]] to the updates from the Emitter.\n * The emitter calls the subscription with the new data each time new data is published into it.\n *\n * ```ts\n * const foo = stream<number>();\n * subscribe(foo, (value) => console.log(value));\n * ```\n *\n * @returns an [[Unsubscribe]] handle  - calling it will unbind the subscription from the emitter.\n *```ts\n * const foo = stream<number>();\n * const unsub = subscribe(foo, (value) => console.log(value));\n * unsub();\n *```\n */\nexport function subscribe<T>(emitter: Emitter<T>, subscription: Subscription<T>): Unsubscribe {\n  return emitter(SUBSCRIBE, subscription)\n}\n\n/**\n * Publishes the value into the passed [[Publisher]].\n *\n * ```ts\n * const foo = stream<number>();\n * publish(foo, 42);\n * ```\n */\nexport function publish<T>(publisher: Publisher<T>, value: T) {\n  publisher(PUBLISH, value)\n}\n\n/**\n * Clears all subscriptions from the [[Emitter]].\n * ```ts\n * const foo = stream<number>();\n * subscribe(foo, (value) => console.log(value));\n * reset(foo);\n * publish(foo, 42);\n * ```\n */\nexport function reset(emitter: Emitter<any>) {\n  emitter(RESET)\n}\n\n/**\n * Extracts the current value from a stateful stream. Use it only as an escape hatch, as it violates the concept of reactive programming.\n * ```ts\n * const foo = statefulStream(42);\n * console.log(getValue(foo));\n * ```\n */\nexport function getValue<T>(depot: StatefulStream<T>): T {\n  return depot(VALUE)\n}\n\n/**\n * Connects two streams - any value emitted from the emitter will be published in the publisher.\n * ```ts\n * const foo = stream<number>();\n * const bar = stream<number>();\n * subscribe(bar, (value) => console.log(`Bar emitted ${value}`));\n *\n * connect(foo, bar);\n * publish(foo);\n * ```\n * @returns an [[Unsubscribe]] handle which will disconnect the two streams.\n */\nexport function connect<T>(emitter: Emitter<T>, publisher: Publisher<T>) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH))\n}\n\n/**\n * Executes the passed subscription at most once, for the next emit from the emitter.\n * ```ts\n * const foo = stream<number>()\n * handleNext(foo, value => console.log(value)) // called once, with 42\n * publish(foo, 42)\n * publish(foo, 43)\n * ```\n * @returns an [[Unsubscribe]] handle to unbind the subscription if necessary.\n */\nexport function handleNext<T>(emitter: Emitter<T>, subscription: Subscription<T>) {\n  const unsub = emitter(SUBSCRIBE, value => {\n    unsub()\n    subscription(value)\n  })\n  return unsub\n}\n","/* eslint-disable @typescript-eslint/no-redeclare */\nexport const PUBLISH = 0 as const\nexport type PUBLISH = typeof PUBLISH\n\nexport const SUBSCRIBE = 1 as const\nexport type SUBSCRIBE = typeof SUBSCRIBE\n\nexport const RESET = 2 as const\nexport type RESET = typeof RESET\n\nexport type VALUE = typeof VALUE\nexport const VALUE = 4 as const\n","/**\n * Streams are the basic building blocks of a reactive system. Think of them as the system permanent \"data tubes\".\n *\n * A stream acts as both an [[Emitter]] and [[Publisher]]. Each stream can have multiple {@link Subscription | Subscriptions}.\n *\n * urx streams are either **stateless** or **stateful**.\n * Stateless streams emit data to existing subscriptions when published, without keeping track of it.\n * Stateful streams remember the last published value and immediately publish it to new subscriptions.\n *\n * ```ts\n * import { stream, statefulStream, publish, subscribe } from \"@virtuoso.dev/urx\";\n *\n * // foo is a stateless stream\n * const foo = stream<number>();\n *\n * publish(foo, 42);\n * // this subsription will not be called...\n * subscribe(foo, (value) => console.log(value));\n * // it will only catch published values after it\n * publish(foo, 43);\n *\n * // stateful streams always start with an initial value\n * const bar = statefulStream(42);\n *\n * // subscribing to a stateful stream\n * // immediately calls the subscription with the current value\n * subscribe(bar, (value) => console.log(value));\n *\n * // subsequent publishing works just like stateless streams\n * publish(bar, 43);\n * ```\n * @packageDocumentation\n */\n\nimport { Emitter, StatefulStream, Stream, Subscription, Unsubscribe, subscribe, connect } from './actions'\nimport { RESET, PUBLISH, SUBSCRIBE, VALUE } from './constants'\nimport { tap, noop } from './utils'\n\n/**\n * Constructs a new stateless stream.\n * ```ts\n * const foo = stream<number>();\n * ```\n * @typeParam T the type of values to publish in the stream.\n * @returns a [[Stream]]\n */\nexport function stream<T>(): Stream<T> {\n  const subscriptions = [] as Array<Subscription<T>>\n\n  return ((action: PUBLISH | SUBSCRIBE | RESET, arg: any) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length)\n        return\n      case SUBSCRIBE:\n        subscriptions.push(arg)\n        return () => {\n          const indexOf = subscriptions.indexOf(arg)\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1)\n          }\n        }\n      case PUBLISH:\n        subscriptions.slice().forEach(subscription => {\n          subscription(arg as T)\n        })\n        return\n      default:\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`unrecognized action ${action}`)\n    }\n  }) as Stream<T>\n}\n\n/**\n * Constructs a new stateful stream.\n * ```ts\n * const foo = statefulStream(42);\n * ```\n * @param initial the initial value in the stream.\n * @typeParam T the type of values to publish in the stream. If omitted, the function infers it from the initial value.\n * @returns a [[StatefulStream]]\n */\nexport function statefulStream<T>(initial: T): StatefulStream<T> {\n  let value: T = initial\n  const innerSubject = stream<T>()\n\n  return ((action: PUBLISH | SUBSCRIBE | RESET | VALUE, arg: any) => {\n    switch (action) {\n      case SUBSCRIBE:\n        ;(arg as Subscription<T>)(value)\n        break\n      case PUBLISH:\n        value = arg as T\n        break\n      case VALUE:\n        return value\n    }\n    return innerSubject(action as any, arg)\n  }) as StatefulStream<T>\n}\n\n/**\n * Event handlers are special emitters which can have **at most one active subscription**.\n * Subscribing to an event handler unsubscribes the previous subscription, if present.\n * ```ts\n * const foo = stream<number>();\n * const fooEvent = eventHandler(foo);\n *\n * // will be called once with 42\n * subscribe(fooEvent, (value) => console.log(`Sub 1 ${value}`));\n * publish(foo, 42);\n *\n * // unsubscribes sub 1\n * subscribe(fooEvent, (value) => console.log(`Sub 2 ${value}`));\n * publish(foo, 43);\n * ```\n * @param emitter the source emitter.\n * @returns the single-subscription emitter.\n */\nexport function eventHandler<T>(emitter: Emitter<T>) {\n  let unsub: Unsubscribe | undefined\n  let currentSubscription: any\n  const cleanup = () => unsub?.()\n\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<T>) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription != null) {\n          if (currentSubscription === subscription) {\n            return\n          }\n          cleanup()\n          currentSubscription = subscription\n          unsub = subscribe(emitter, subscription)\n          return unsub\n        } else {\n          cleanup()\n          return noop\n        }\n      case RESET:\n        cleanup()\n        currentSubscription = null\n        return\n      default:\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<T>\n}\n\n/**\n * Creates and connects a \"junction\" stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\n *\n * ```ts\n * const foo = stream<number>();\n *\n * const fooX2 = pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`multiplying ${value}`);\n *     return value * 2;\n *   })\n * );\n *\n * subscribe(fooX2, (value) => console.log(value));\n * subscribe(fooX2, (value) => console.log(value));\n *\n * publish(foo, 42); // executes the map operator twice for each subscription.\n *\n * const sharedFooX2 = streamFromEmitter(pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`shared multiplying ${value}`);\n *     return value * 2;\n *   })\n * ));\n *\n * subscribe(sharedFooX2, (value) => console.log(value));\n * subscribe(sharedFooX2, (value) => console.log(value));\n *\n * publish(foo, 42);\n *```\n * @returns the resulting stream.\n */\nexport function streamFromEmitter<T>(emitter: Emitter<T>): Stream<T> {\n  return tap(stream<T>(), stream => connect(emitter, stream))\n}\n\n/**\n * Creates and connects a \"junction\" stateful stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\n *\n * ```ts\n * const foo = stream<number>();\n *\n * const fooX2 = pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`multiplying ${value}`);\n *     return value * 2;\n *   })\n * );\n *\n * subscribe(fooX2, (value) => console.log(value));\n * subscribe(fooX2, (value) => console.log(value));\n *\n * publish(foo, 42); // executes the map operator twice for each subscription.\n *\n * const sharedFooX2 = statefulStreamFromEmitter(pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`shared multiplying ${value}`);\n *     return value * 2;\n *   })\n * ), 42);\n *\n * subscribe(sharedFooX2, (value) => console.log(value));\n * subscribe(sharedFooX2, (value) => console.log(value));\n *\n * publish(foo, 42);\n *```\n * @param initial the initial value in the stream.\n * @returns the resulting stateful stream.\n */\nexport function statefulStreamFromEmitter<T>(emitter: Emitter<T>, initial: T): StatefulStream<T> {\n  return tap(statefulStream(initial), stream => connect(emitter, stream))\n}\n","/**\n *\n * Stream values can be transformed and controlled by {@link pipe | **piping**} through **operators**.\n * urx includes several operators like [[map]], [[filter]], [[scan]], and [[throttleTime]].\n * The [[withLatestFrom]] operator allows the combination of values from other streams.\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\n * subscribe(bar, value => console.log(value))\n * publish(foo, 2) // outputs 8\n * ```\n *\n * ### Implementing Custom Operators\n * To implement your own operators, implement the [[Operator]] interface.\n * @packageDocumentation\n */\nimport { compose, thrush } from './utils'\nimport { Emitter, subscribe, Subscription, reset } from './actions'\nimport { SUBSCRIBE, RESET } from './constants'\n\n/**\n * Operators can transform and control the flow of values.\n * [[pipe]] is used to transform one Emitter into another by stacking operators to its values.\n * To build your own operator that looks like the built-in ones,\n * create a function which returns an operator.\n * The following custom operator multiplies the passed value:\n *\n * ```ts\n * function multiplyBy(multiplier: number): Operator<number> {\n *  return done => value => done(value * multiplier)\n * }\n *\n * const foo = stream<number>()\n * const multipliedFoo = pipe(foo, multiplyBy(3))\n * subscribe(multipliedFoo, value => console.log(value))\n * publish(foo, 42)\n * ```\n */\n\nexport type Operator<Input, Output = Input> = (done: (value: Output) => void) => (value: Input) => void\n\n/** @internal */\ntype CombineOperatorsReturnType<I, O> = (subscriber: (value: O) => void) => (value: I) => void\n\n/** @internal */\nfunction combineOperators<I>(...operators: Array<Operator<any, any>>): CombineOperatorsReturnType<I, any> {\n  return (subscriber: (value: any) => void) => {\n    return operators.reduceRight(thrush, subscriber)\n  }\n}\n\n/** @internal */\ntype O<I, OP> = Operator<I, OP>\n\n/**\n * Creates a new emitter from the passed one by piping its values through one or more operators.\n * Operators can perform various actions like filter values, pull values from other emitters, or compute new values.\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\n * subscribe(bar, value => console.log(value))\n * publish(foo, 2) // outputs 8\n * ```\n * #### Sharing Subscription Calculations\n *\n * `pipe` acts as a proxy for the source emitter, and re-runs the operators for each subscription to the derived emitter.\n * Use [[streamFromEmitter]] or [[statefulStreamFromEmitter]] to avoid that.\n */\nexport function pipe<T>(s: Emitter<T>): Emitter<T> // prettier-ignore\nexport function pipe<T, O1>(s: Emitter<T>, o1: O<T, O1>): Emitter<O1> // prettier-ignore\nexport function pipe<T, O1, O2>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>]): Emitter<O2> // prettier-ignore\nexport function pipe<T, O1, O2, O3>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>]): Emitter<O3> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>]): Emitter<O4> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>]): Emitter<O5> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5, O6>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>]): Emitter<O6> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5, O6, O7>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>, O<O6, O7>]): Emitter<O7> // prettier-ignore\nexport function pipe<T>(source: Emitter<T>, ...operators: Array<O<any, any>>): Emitter<any> {\n  // prettier-ignore\n  const project = combineOperators(...operators)\n  return ((action: SUBSCRIBE | RESET, subscription: Subscription<any>) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription))\n      case RESET:\n        reset(source)\n        return\n      default:\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`unrecognized action ${action}`)\n    }\n  }) as Emitter<any>\n}\n\n/**\n * A function which determines if two values are equal.\n * Implement custom comparators when [[distinctUntilChanged]] needs to work on non-primitive objects.\n * @returns true if values should be considered equal.\n */\nexport type Comparator<T> = (previous: T, next: T) => boolean\n\n/**\n * The default [[Comparator]] for [[distinctUntilChanged]] and [[duc]].\n */\nexport function defaultComparator<T>(previous: T, next: T) {\n  return previous === next\n}\n\n/**\n * Filters out identical values. Pass an optional [[Comparator]] if you need to filter non-primitive values.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, distinctUntilChanged()),\n *  console.log\n * ) // will be called only once\n *\n * publish(foo, 42)\n * publish(foo, 42)\n * ```\n */\nexport function distinctUntilChanged<T>(comparator: Comparator<T> = defaultComparator): Operator<T> {\n  let current: T\n  return done => next => {\n    if (!comparator(current, next)) {\n      current = next\n      done(next)\n    }\n  }\n}\n\n/**\n * Filters out values for which the predicator does not return `true`-ish.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, filter(value => value % 2 === 0)),\n *  console.log\n * ) // will be called only with even values\n *\n * publish(foo, 2)\n * publish(foo, 3)\n * publish(foo, 4)\n * publish(foo, 5)\n * ```\n */\nexport function filter<T>(predicate: (value: T) => boolean): Operator<T> {\n  return done => value => {\n    predicate(value) && done(value)\n  }\n}\n\n/**\n * Maps values using the provided project function.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, map(value => value * 2)),\n *  console.log\n * ) // 4, 6\n *\n * publish(foo, 2)\n * publish(foo, 3)\n * ```\n */\nexport function map<T, K>(project: (value: T) => K): Operator<T, K> {\n  return done => compose(done, project)\n}\n\n/**\n * Maps values to the hard-coded value.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, mapTo(3)),\n *  console.log\n * ) // 3, 3\n *\n * publish(foo, 1)\n * publish(foo, 2)\n * ```\n */\nexport function mapTo<T>(value: T): Operator<any, T> {\n  return done => () => done(value)\n}\n\n/**\n * Works like Array#reduce.\n * Applies an accumulator function on the emitter, and outputs intermediate result. Starts with the initial value.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, scan((acc, value) => acc + value, 2),\n *  console.log\n * ) // 3, 5\n *\n * publish(foo, 1)\n * publish(foo, 2)\n * ```\n */\nexport function scan<T, K>(scanner: (current: T, value: K) => T, initial: T): Operator<K, T> {\n  return done => value => done((initial = scanner(initial, value)))\n}\n\n/**\n * Skips the specified amount of values from the emitter.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, skip(2)),\n *  console.log\n * ) // 3, 4\n *\n * publish(foo, 1) // skipped\n * publish(foo, 2) // skipped\n * publish(foo, 3)\n * publish(foo, 4)\n * ```\n */\nexport function skip<T>(times: number): Operator<T> {\n  return done => value => {\n    times > 0 ? times-- : done(value)\n  }\n}\n\n/**\n * Throttles flowing values at the provided interval in milliseconds.\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\n *\n * ```ts\n *  const foo = stream<number>()\n *  publish(foo, 1)\n *\n *  setTimeout(() => publish(foo, 2), 20)\n *  setTimeout(() => publish(foo, 3), 20)\n *\n *  subscribe(pipe(foo, throttleTime(50)), val => {\n *    console.log(value); // 3\n *  })\n * ```\n */\nexport function throttleTime<T>(interval: number): Operator<T> {\n  let currentValue: T | undefined\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  return done => value => {\n    currentValue = value\n\n    if (timeout === undefined) {\n      return\n    }\n\n    timeout = setTimeout(() => {\n      timeout = undefined\n      done(currentValue!)\n    }, interval)\n  }\n}\n\n/**\n * Debounces flowing values at the provided interval in milliseconds.\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\n *\n * ```ts\n *  const foo = stream<number>()\n *  publish(foo, 1)\n *\n *  setTimeout(() => publish(foo, 2), 20)\n *  setTimeout(() => publish(foo, 3), 20)\n *\n *  subscribe(pipe(foo, debounceTime(50)), val => {\n *    console.log(value); // 3\n *  })\n * ```\n */\nexport function debounceTime<T>(interval: number): Operator<T> {\n  let currentValue: T | undefined\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  return done => value => {\n    currentValue = value\n    if (timeout != null) {\n      clearTimeout(timeout)\n    }\n\n    timeout = setTimeout(() => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      done(currentValue!)\n    }, interval)\n  }\n}\n\n/**\n * Combines the source Emitter with the latest values from the specified Emitters into an array. Outputs only when the source Emitter emits.\n * See [[combineLatest]] for a transformer that outputs when any of the emitters emit.\n *\n * ```ts\n *  const foo = stream<number>()\n *  const bar = stream<number>()\n *  subscribe(\n *    pipe(\n *      foo,\n *      withLatestFrom(bar)\n *    ),\n *    (([foo, bar]) => console.log({ foo, bar }))\n *  )\n *\n *  publish(foo, 1) // nothing happens, bar has not emitted yet\n *  publish(bar, 1) // still nothing\n *  publish(foo, 2) // logs { foo: 2, bar: 1 }\n *  publish(bar, 2)\n *  publish(foo, 3) // logs { foo: 3, bar: 2 }\n * ```\n */\nexport function withLatestFrom<T, R1>(...s: [Emitter<R1>]): Operator<T, [T, R1]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2>(...s: [Emitter<R1>, Emitter<R2>]): Operator<T, [T, R1, R2]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>]): Operator<T, [T, R1, R2, R3]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>]): Operator<T, [T, R1, R2, R3, R4]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>]): Operator<T, [T, R1, R2, R3, R4, R5]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>, Emitter<R6>]): Operator<T, [T, R1, R2, R3, R4, R5, R6]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6, R7>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>, Emitter<R6>, Emitter<R7>]): Operator<T, [T, R1, R2, R3, R4, R5, R6, R7]> // prettier-ignore\nexport function withLatestFrom(...sources: Array<Emitter<any>>): Operator<any, any> {\n  const values = new Array(sources.length)\n  let called = 0\n  let pendingCall: null | (() => void) = null\n  const allCalled = Math.pow(2, sources.length) - 1\n\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index)\n    subscribe(source, value => {\n      const prevCalled = called\n      called = called | bit\n      values[index] = value\n      if (prevCalled !== allCalled && called === allCalled && pendingCall != null) {\n        pendingCall()\n        pendingCall = null\n      }\n    })\n  })\n\n  return done => value => {\n    const call = () => done([value].concat(values))\n    if (called === allCalled) {\n      call()\n    } else {\n      pendingCall = call\n    }\n  }\n}\n","/**\n * Transformers change and combine streams, similar to operators.\n * urx comes with two combinators - [[combineLatest]] and [[merge]], and one convenience filter - [[duc]].\n *\n * @packageDocumentation\n */\nimport { Emitter, publish, reset, subscribe, Subscription } from './actions'\nimport { RESET, SUBSCRIBE } from './constants'\nimport { Comparator, defaultComparator, distinctUntilChanged, pipe } from './pipe'\nimport { stream } from './streams'\nimport { joinProc } from './utils'\n\n/**\n * Merges one or more emitters from the same type into a new Emitter which emits values from any of the source emitters.\n * ```ts\n * const foo = stream<number>()\n * const bar = stream<number>()\n *\n * subscribe(merge(foo, bar), (value) => console.log(value)) // 42, 43\n *\n * publish(foo, 42)\n * publish(bar, 43)\n * ```\n */\nexport function merge<T>(...sources: Array<Emitter<T>>): Emitter<T> {\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<any>) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map(source => subscribe(source, subscription!)))\n      case RESET:\n        // do nothing, we are stateless\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<T>\n}\n\n/**\n * A convenience wrapper that emits only the distinct values from the passed Emitter. Wraps [[pipe]] and [[distinctUntilChanged]].\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // this line...\n * const a = duc(foo)\n *\n * // is equivalent to this\n * const b = pipe(distinctUntilChanged(foo))\n * ```\n *\n * @param source The source emitter.\n * @param comparator optional custom comparison function for the two values.\n *\n * @typeParam T the type of the value emitted by the source.\n *\n * @returns the resulting emitter.\n */\nexport function duc<T>(source: Emitter<T>, comparator: Comparator<T> = defaultComparator): Emitter<T> {\n  return pipe(source, distinctUntilChanged(comparator))\n}\n\n/**\n * Creates an emitter with the latest values from all passed emitters as an array.\n *\n * `combineLatest` acts as a Depot. Using it on stateless streams persists the last emitted value of each [[Emitter]].\n * Provided that all emitters have emitted at least once, subscribing to the resulting emitter will immediately receive their combined latest values.\n *\n * ```ts\n * const foo = stream<number>()\n * const bar = stream<number>()\n *\n * subscribe(combineLatest(foo, bar), ([foo, bar]) => console.log({ foo, bar }))\n *\n * publish(foo, 42)\n * publish(bar, 43) // { foo: 42, bar: 43 }\n * publish(foo, 44) // { foo: 44, bar: 43 }\n * publish(bar, 45) // { foo: 44, bar: 45 }\n * ```\n */\nexport function combineLatest<O1, O2>(...emitters: [Emitter<O1>, Emitter<O2>]): Emitter<[O1, O2]> // prettier-ignore\nexport function combineLatest<O1, O2, O3>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>]): Emitter<[O1, O2, O3]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>]): Emitter<[O1, O2, O3, O4]> // prettier-ignore\nexport function combineLatest<O1, O2, O3>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>]): Emitter<[O1, O2, O3]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>]): Emitter<[O1, O2, O3, O4, O5]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>]): Emitter<[O1, O2, O3, O4, O5, O6]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>]): Emitter<[O1, O2, O3, O4, O5, O6, O7]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9, O10>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>, Emitter<O10>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>, Emitter<O10>, Emitter<O11>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11]> // prettier-ignore\nexport function combineLatest(...emitters: Array<Emitter<any>>): Emitter<any> {\n  const innerSubject = stream<any>()\n  const values = new Array(emitters.length)\n  let called = 0\n  const allCalled = Math.pow(2, emitters.length) - 1\n\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index)\n    subscribe(source, value => {\n      values[index] = value\n      called = called | bit\n      if (called === allCalled) {\n        publish(innerSubject, values)\n      }\n    })\n  })\n\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<any>) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription!(values)\n        }\n        return subscribe(innerSubject, subscription!)\n      case RESET:\n        return reset(innerSubject)\n      default:\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<any>\n}\n","/**\n * ## Thinking in Systems\n * systems are a stateful **data-processing machines** which accept input through **input streams**,\n * init and maintain state in **depots** and, in certain conditions, emit values to subscriptions through **output streams**.\n * Systems can specify other systems as dependencies, and can act as singletons in the resulting dependency tree.\n *\n * ### Depots\n *\n * The first, and probably the most critical part to understand are **the depots**\n * mostly because they are somewhat implicit.\n * Unlike other state management paradigms, the depots are not kept in a single data structure.\n * Insted, depots are defined and maintained as stateful streams, stateful transfomers\n * like [[combineLatest]] or stateful operators like[ []withLatestFrom] or [[scan]].\n *\n * **Depots persist values over time**.\n * If it was not for them, the system had to re-receive its entire input state simultaneously in order to calculate the values for its output stream.\n *\n * Of course, strictly speaking, it is possible to implement a pure, stateless system as a form of a complex map/reduce. urx would not mind that ;).\n *\n * ### Input Streams\n *\n * The system receives updates from the rest of the world through values published in its input streams.\n * The streams used can be either stateless (acting as means to send **signals**) or stateful, where the initial stream state acts as the default value for that system parameter.\n *\n * The effects of the input streams are up to the system data-processing logic. It can change its depots' state, and/or emit values through its output streams.\n *\n * ### Data Processing\n *\n * The actual system behavior is exclusively implemented by **applying transformers and operators** to the input streams, producing the respective output streams.\n * In the final state the system streams are organized in a directed graph, where incoming data is routed through certain edges and nodes.\n * Simple systems like the one in [urx by example](https://urx.virtuoso.dev/docs/urx-by-example) can use a straightforward single-step transformation (in this case, `combineLatest` and `map`),\n * while complex ones can introduce multiple intermediate streams to model their logic.\n *\n * ### Output Streams\n *\n * The system publishes updates to its clients (other systems or an UI bound to it) by publishing data in its output streams.\n * State-reflecting output streams, like `sum` in the [urx by example](https://urx.virtuoso.dev/docs/urx-by-example) should use stateful streams as output streams.\n * Signal-like output should use regular, stateless streams. In general, stateless input streams tend to have a symmetrical stateless streams, and the opposite.\n *\n * @packageDocumentation\n */\nimport { Emitter } from './actions'\n\n/**\n * Systems are a dictionaries of streams. a [[SystemConstructor]] should return a System.\n */\nexport interface System {\n  [key: string]: Emitter<any>\n}\n\n/**\n * a SystemSpec is the result from a [[system]] call. To obtain the [[System]], pass the spec to [[init]].\n */\nexport interface SystemSpec<SS extends SystemSpecs, C extends SystemConstructor<SS>> {\n  id: string\n  constructor: C\n  dependencies: SS\n  singleton: boolean\n}\n\n/** @internal **/\nexport type AnySystemSpec = SystemSpec<any, any>\n\n/** @internal **/\nexport type SystemSpecs = AnySystemSpec[]\n\n/** @internal **/\nexport type SR<E extends AnySystemSpec, R extends System = ReturnType<E['constructor']>> = R\n\n/** @internal **/\ntype SpecResultsRec<SS extends any[], Acc extends any[]> = SS extends [infer Head, ...(infer Tail)]\n  ? Head extends AnySystemSpec\n    ? SpecResultsRec<Tail, [...Acc, SR<Head>]>\n    : never\n  : Acc\n\n/** @internal **/\nexport type SpecResults<SS extends SystemSpecs> = SpecResultsRec<SS, []>\n\n/**\n * The system constructor is a function which initializes and connects streams and returns them as a [[System]].\n * If the [[system]] call specifies system dependencies, the constructor receives the dependencies as an array argument.\n */\nexport type SystemConstructor<D extends SystemSpecs> = (dependencies: SpecResults<D>) => System\n\n/**\n * `system` defines a specification of a system - its constructor, dependencies and if it should act as a singleton in a system dependency tree.\n * When called, system returns a [[SystemSpec]], which is then initialized along with its dependencies by passing it to [[init]].\n *\n * ```ts\n * @import { subscribe, publish, system, init, tup, connect, map, pipe } from 'urx'\n *\n * // a simple system with two streams\n * const sys1 = system(() => {\n *  const a = stream<number>()\n *  const b = stream<number>()\n *\n *  connect(pipe(a, map(value => value * 2)), b)\n *  return { a, b }\n * })\n *\n * // a second system which depends on the streams from the first one\n * const sys2 = system(([ {a, b} ]) => {\n *  const c = stream<number>()\n *  connect(pipe(b, map(value => value * 2)), c)\n *  // re-export the `a` stream, keep `b` internal\n *  return { a, c }\n * }, tup(sys1))\n *\n * // init will recursively initialize sys2 dependencies, in this case sys1\n * const { a, c } = init(sys2)\n * subscribe(c, c => console.log(`Value multiplied by 4`, c))\n * publish(a, 2)\n * ```\n *\n * #### Singletons in Dependency Tree\n *\n * By default, systems will be initialized only once if encountered multiple times in the dependency tree.\n * In the below dependency system tree, systems `b` and `c` will receive the same stream instances from system `a` when system `d` is initialized.\n * ```txt\n *   a\n *  / \\\n * b   c\n *  \\ /\n *   d\n * ```\n * If `a` gets `{singleton: false}` as a last argument, `init` creates two separate instances - one for `b` and one for `c`.\n *\n * @param constructor the system constructor function. Initialize and connect the streams in its body.\n *\n * @param dependencies the system dependencies, which the constructor will receive as arguments.\n * Use the [[tup]] utility **For TypeScript type inference to work correctly**.\n * ```ts\n * const sys3 = system(() => { ... }, tup(sys2, sys1))\n * ```\n * @param __namedParameters Options\n * @param singleton determines if the system will act as a singleton in a system dependency tree. `true` by default.\n */\nexport function system<F extends SystemConstructor<D>, D extends SystemSpecs>(\n  constructor: F,\n  dependencies: D = ([] as unknown) as D,\n  { singleton }: { singleton: boolean } = { singleton: true }\n): SystemSpec<D, F> {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton,\n  }\n}\n\n/** @internal */\nconst id = () => (Symbol() as unknown) as string\n\n/**\n * Initializes a [[SystemSpec]] by recursively initializing its dependencies.\n *\n * ```ts\n * // a simple system with two streams\n * const sys1 = system(() => {\n *  const a = stream<number>()\n *  const b = stream<number>()\n *\n *  connect(pipe(a, map(value => value * 2)), b)\n *  return { a, b }\n * })\n *\n * const { a, b } = init(sys1)\n * subscribe(b, b => console.log(b))\n * publish(a, 2)\n * ```\n *\n * @returns the [[System]] constructed by the spec constructor.\n * @param systemSpec the system spec to initialize.\n */\nexport function init<SS extends AnySystemSpec>(systemSpec: SS): SR<SS> {\n  const singletons = new Map<string, System>()\n  const _init = <SS extends AnySystemSpec>({ id, constructor, dependencies, singleton }: SS) => {\n    if (singleton && singletons.has(id)) {\n      return singletons.get(id)! as SR<SS>\n    }\n    const system = constructor(dependencies.map((e: AnySystemSpec) => _init(e)))\n    if (singleton) {\n      singletons.set(id, system)\n    }\n    return system\n  }\n  return _init(systemSpec)\n}\n"]},"metadata":{},"sourceType":"module"}