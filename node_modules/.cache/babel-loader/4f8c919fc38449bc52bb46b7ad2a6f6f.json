{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ICAL = require('ical.js'); // Copied from https://dxr.mozilla.org/comm-central/source/calendar/timezones/zones.json\n// And compiled using node compile-zones.js\n// See also https://github.com/mozilla-comm/ical.js/issues/195\n\n\nvar timezones = require('./zones-compiled.json');\n\nvar IcalExpander = /*#__PURE__*/function () {\n  function IcalExpander(opts) {\n    _classCallCheck(this, IcalExpander);\n\n    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1000;\n    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;\n    this.jCalData = ICAL.parse(opts.ics);\n    this.component = new ICAL.Component(this.jCalData);\n    this.events = this.component.getAllSubcomponents('vevent').map(function (vevent) {\n      return new ICAL.Event(vevent);\n    });\n\n    if (this.skipInvalidDates) {\n      this.events = this.events.filter(function (evt) {\n        try {\n          evt.startDate.toJSDate();\n          evt.endDate.toJSDate();\n          return true;\n        } catch (err) {\n          // skipping events with invalid time\n          return false;\n        }\n      });\n    }\n  }\n\n  _createClass(IcalExpander, [{\n    key: \"between\",\n    value: function between(after, before) {\n      var _this = this;\n\n      function isEventWithinRange(startTime, endTime) {\n        return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());\n      }\n\n      function getTimes(eventOrOccurrence) {\n        var startTime = eventOrOccurrence.startDate.toJSDate().getTime();\n        var endTime = eventOrOccurrence.endDate.toJSDate().getTime(); // If it is an all day event, the end date is set to 00:00 of the next day\n        // So we need to make it be 23:59:59 to compare correctly with the given range\n\n        if (eventOrOccurrence.endDate.isDate && endTime > startTime) {\n          endTime -= 1;\n        }\n\n        return {\n          startTime: startTime,\n          endTime: endTime\n        };\n      }\n\n      var exceptions = [];\n      this.events.forEach(function (event) {\n        if (event.isRecurrenceException()) exceptions.push(event);\n      });\n      var ret = {\n        events: [],\n        occurrences: []\n      };\n      this.events.filter(function (e) {\n        return !e.isRecurrenceException();\n      }).forEach(function (event) {\n        var exdates = [];\n        event.component.getAllProperties('exdate').forEach(function (exdateProp) {\n          var exdate = exdateProp.getFirstValue();\n          exdates.push(exdate.toJSDate().getTime());\n        }); // Recurring event is handled differently\n\n        if (event.isRecurring()) {\n          var iterator = event.iterator();\n          var next;\n          var i = 0;\n\n          do {\n            i += 1;\n            next = iterator.next();\n\n            if (next) {\n              var _ret = function () {\n                var occurrence = event.getOccurrenceDetails(next);\n\n                var _getTimes = getTimes(occurrence),\n                    startTime = _getTimes.startTime,\n                    endTime = _getTimes.endTime;\n\n                var isOccurrenceExcluded = exdates.indexOf(startTime) !== -1; // TODO check that within same day?\n\n                var exception = exceptions.find(function (ex) {\n                  return ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime();\n                }); // We have passed the max date, stop\n\n                if (before && startTime > before.getTime()) return \"break\"; // Check that we are within our range\n\n                if (isEventWithinRange(startTime, endTime)) {\n                  if (exception) {\n                    ret.events.push(exception);\n                  } else if (!isOccurrenceExcluded) {\n                    ret.occurrences.push(occurrence);\n                  }\n                }\n              }();\n\n              if (_ret === \"break\") break;\n            }\n          } while (next && (!_this.maxIterations || i < _this.maxIterations));\n\n          return;\n        } // Non-recurring event:\n\n\n        var _getTimes2 = getTimes(event),\n            startTime = _getTimes2.startTime,\n            endTime = _getTimes2.endTime;\n\n        if (isEventWithinRange(startTime, endTime)) ret.events.push(event);\n      });\n      return ret;\n    }\n  }, {\n    key: \"before\",\n    value: function before(_before) {\n      return this.between(undefined, _before);\n    }\n  }, {\n    key: \"after\",\n    value: function after(_after) {\n      return this.between(_after);\n    }\n  }, {\n    key: \"all\",\n    value: function all() {\n      return this.between();\n    }\n  }]);\n\n  return IcalExpander;\n}();\n\nfunction registerTimezones() {\n  Object.keys(timezones).forEach(function (key) {\n    var icsData = timezones[key];\n    var icsTimezone = \"BEGIN:VTIMEZONE\\r\\nTZID:\".concat(key, \"\\r\\n\").concat(icsData, \"\\r\\nEND:VTIMEZONE\");\n    var parsed = ICAL.parse(\"BEGIN:VCALENDAR\\nPRODID:-//tzurl.org//NONSGML Olson 2012h//EN\\nVERSION:2.0\\n\".concat(icsTimezone, \"\\nEND:VCALENDAR\"));\n    var comp = new ICAL.Component(parsed);\n    var vtimezone = comp.getFirstSubcomponent('vtimezone');\n    ICAL.TimezoneService.register(key, new ICAL.Timezone(vtimezone));\n  });\n}\n\nregisterTimezones();\nmodule.exports = IcalExpander;","map":{"version":3,"sources":["/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/ical-expander/index.js"],"names":["ICAL","require","timezones","IcalExpander","opts","maxIterations","skipInvalidDates","jCalData","parse","ics","component","Component","events","getAllSubcomponents","map","vevent","Event","filter","evt","startDate","toJSDate","endDate","err","after","before","isEventWithinRange","startTime","endTime","getTime","getTimes","eventOrOccurrence","isDate","exceptions","forEach","event","isRecurrenceException","push","ret","occurrences","e","exdates","getAllProperties","exdateProp","exdate","getFirstValue","isRecurring","iterator","next","i","occurrence","getOccurrenceDetails","isOccurrenceExcluded","indexOf","exception","find","ex","uid","recurrenceId","between","undefined","registerTimezones","Object","keys","key","icsData","icsTimezone","parsed","comp","vtimezone","getFirstSubcomponent","TimezoneService","register","Timezone","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,SAAD,CAApB,C,CAEA;AACA;AACA;;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,uBAAD,CAAzB;;IAEME,Y;AACJ,wBAAYC,IAAZ,EAAkB;AAAA;;AAChB,SAAKC,aAAL,GAAqBD,IAAI,CAACC,aAAL,IAAsB,IAAtB,GAA6BD,IAAI,CAACC,aAAlC,GAAkD,IAAvE;AACA,SAAKC,gBAAL,GAAwBF,IAAI,CAACE,gBAAL,IAAyB,IAAzB,GAAgCF,IAAI,CAACE,gBAArC,GAAwD,KAAhF;AAEA,SAAKC,QAAL,GAAgBP,IAAI,CAACQ,KAAL,CAAWJ,IAAI,CAACK,GAAhB,CAAhB;AACA,SAAKC,SAAL,GAAiB,IAAIV,IAAI,CAACW,SAAT,CAAmB,KAAKJ,QAAxB,CAAjB;AACA,SAAKK,MAAL,GAAc,KAAKF,SAAL,CAAeG,mBAAf,CAAmC,QAAnC,EAA6CC,GAA7C,CAAiD,UAAAC,MAAM;AAAA,aAAI,IAAIf,IAAI,CAACgB,KAAT,CAAeD,MAAf,CAAJ;AAAA,KAAvD,CAAd;;AAEA,QAAI,KAAKT,gBAAT,EAA2B;AACzB,WAAKM,MAAL,GAAc,KAAKA,MAAL,CAAYK,MAAZ,CAAmB,UAACC,GAAD,EAAS;AACxC,YAAI;AACFA,UAAAA,GAAG,CAACC,SAAJ,CAAcC,QAAd;AACAF,UAAAA,GAAG,CAACG,OAAJ,CAAYD,QAAZ;AACA,iBAAO,IAAP;AACD,SAJD,CAIE,OAAOE,GAAP,EAAY;AACZ;AACA,iBAAO,KAAP;AACD;AACF,OATa,CAAd;AAUD;AACF;;;;WAED,iBAAQC,KAAR,EAAeC,MAAf,EAAuB;AAAA;;AACrB,eAASC,kBAAT,CAA4BC,SAA5B,EAAuCC,OAAvC,EAAgD;AAC9C,eAAO,CAAC,CAACJ,KAAD,IAAUI,OAAO,IAAIJ,KAAK,CAACK,OAAN,EAAtB,MACN,CAACJ,MAAD,IAAWE,SAAS,IAAIF,MAAM,CAACI,OAAP,EADlB,CAAP;AAED;;AAED,eAASC,QAAT,CAAkBC,iBAAlB,EAAqC;AACnC,YAAMJ,SAAS,GAAGI,iBAAiB,CAACX,SAAlB,CAA4BC,QAA5B,GAAuCQ,OAAvC,EAAlB;AACA,YAAID,OAAO,GAAGG,iBAAiB,CAACT,OAAlB,CAA0BD,QAA1B,GAAqCQ,OAArC,EAAd,CAFmC,CAInC;AACA;;AACA,YAAIE,iBAAiB,CAACT,OAAlB,CAA0BU,MAA1B,IAAqCJ,OAAO,GAAGD,SAAnD,EAA+D;AAC7DC,UAAAA,OAAO,IAAI,CAAX;AACD;;AAED,eAAO;AAAED,UAAAA,SAAS,EAATA,SAAF;AAAaC,UAAAA,OAAO,EAAPA;AAAb,SAAP;AACD;;AAED,UAAMK,UAAU,GAAG,EAAnB;AAEA,WAAKpB,MAAL,CAAYqB,OAAZ,CAAoB,UAACC,KAAD,EAAW;AAC7B,YAAIA,KAAK,CAACC,qBAAN,EAAJ,EAAmCH,UAAU,CAACI,IAAX,CAAgBF,KAAhB;AACpC,OAFD;AAIA,UAAMG,GAAG,GAAG;AACVzB,QAAAA,MAAM,EAAE,EADE;AAEV0B,QAAAA,WAAW,EAAE;AAFH,OAAZ;AAKA,WAAK1B,MAAL,CAAYK,MAAZ,CAAmB,UAAAsB,CAAC;AAAA,eAAI,CAACA,CAAC,CAACJ,qBAAF,EAAL;AAAA,OAApB,EAAoDF,OAApD,CAA4D,UAACC,KAAD,EAAW;AACrE,YAAMM,OAAO,GAAG,EAAhB;AAEAN,QAAAA,KAAK,CAACxB,SAAN,CAAgB+B,gBAAhB,CAAiC,QAAjC,EAA2CR,OAA3C,CAAmD,UAACS,UAAD,EAAgB;AACjE,cAAMC,MAAM,GAAGD,UAAU,CAACE,aAAX,EAAf;AACAJ,UAAAA,OAAO,CAACJ,IAAR,CAAaO,MAAM,CAACvB,QAAP,GAAkBQ,OAAlB,EAAb;AACD,SAHD,EAHqE,CAQrE;;AACA,YAAIM,KAAK,CAACW,WAAN,EAAJ,EAAyB;AACvB,cAAMC,QAAQ,GAAGZ,KAAK,CAACY,QAAN,EAAjB;AAEA,cAAIC,IAAJ;AACA,cAAIC,CAAC,GAAG,CAAR;;AAEA,aAAG;AACDA,YAAAA,CAAC,IAAI,CAAL;AACAD,YAAAA,IAAI,GAAGD,QAAQ,CAACC,IAAT,EAAP;;AACA,gBAAIA,IAAJ,EAAU;AAAA;AACR,oBAAME,UAAU,GAAGf,KAAK,CAACgB,oBAAN,CAA2BH,IAA3B,CAAnB;;AADQ,gCAGuBlB,QAAQ,CAACoB,UAAD,CAH/B;AAAA,oBAGAvB,SAHA,aAGAA,SAHA;AAAA,oBAGWC,OAHX,aAGWA,OAHX;;AAKR,oBAAMwB,oBAAoB,GAAGX,OAAO,CAACY,OAAR,CAAgB1B,SAAhB,MAA+B,CAAC,CAA7D,CALQ,CAOR;;AACA,oBAAM2B,SAAS,GAAGrB,UAAU,CAACsB,IAAX,CAAgB,UAAAC,EAAE;AAAA,yBAAIA,EAAE,CAACC,GAAH,KAAWtB,KAAK,CAACsB,GAAjB,IAAwBD,EAAE,CAACE,YAAH,CAAgBrC,QAAhB,GAA2BQ,OAA3B,OAAyCqB,UAAU,CAAC9B,SAAX,CAAqBC,QAArB,GAAgCQ,OAAhC,EAArE;AAAA,iBAAlB,CAAlB,CARQ,CAUR;;AACA,oBAAIJ,MAAM,IAAIE,SAAS,GAAGF,MAAM,CAACI,OAAP,EAA1B,EAA4C,eAXpC,CAaR;;AACA,oBAAIH,kBAAkB,CAACC,SAAD,EAAYC,OAAZ,CAAtB,EAA4C;AAC1C,sBAAI0B,SAAJ,EAAe;AACbhB,oBAAAA,GAAG,CAACzB,MAAJ,CAAWwB,IAAX,CAAgBiB,SAAhB;AACD,mBAFD,MAEO,IAAI,CAACF,oBAAL,EAA2B;AAChCd,oBAAAA,GAAG,CAACC,WAAJ,CAAgBF,IAAhB,CAAqBa,UAArB;AACD;AACF;AApBO;;AAAA,oCAWoC;AAU7C;AACF,WAzBD,QA0BOF,IAAI,KAAK,CAAC,KAAI,CAAC1C,aAAN,IAAuB2C,CAAC,GAAG,KAAI,CAAC3C,aAArC,CA1BX;;AA4BA;AACD,SA5CoE,CA8CrE;;;AA9CqE,yBA+CtCwB,QAAQ,CAACK,KAAD,CA/C8B;AAAA,YA+C7DR,SA/C6D,cA+C7DA,SA/C6D;AAAA,YA+ClDC,OA/CkD,cA+ClDA,OA/CkD;;AAiDrE,YAAIF,kBAAkB,CAACC,SAAD,EAAYC,OAAZ,CAAtB,EAA4CU,GAAG,CAACzB,MAAJ,CAAWwB,IAAX,CAAgBF,KAAhB;AAC7C,OAlDD;AAoDA,aAAOG,GAAP;AACD;;;WAED,gBAAOb,OAAP,EAAe;AACb,aAAO,KAAKkC,OAAL,CAAaC,SAAb,EAAwBnC,OAAxB,CAAP;AACD;;;WAED,eAAMD,MAAN,EAAa;AACX,aAAO,KAAKmC,OAAL,CAAanC,MAAb,CAAP;AACD;;;WAED,eAAM;AACJ,aAAO,KAAKmC,OAAL,EAAP;AACD;;;;;;AAGH,SAASE,iBAAT,GAA6B;AAC3BC,EAAAA,MAAM,CAACC,IAAP,CAAY5D,SAAZ,EAAuB+B,OAAvB,CAA+B,UAAC8B,GAAD,EAAS;AACtC,QAAMC,OAAO,GAAG9D,SAAS,CAAC6D,GAAD,CAAzB;AACA,QAAME,WAAW,qCAA8BF,GAA9B,iBAAwCC,OAAxC,sBAAjB;AACA,QAAME,MAAM,GAAGlE,IAAI,CAACQ,KAAL,uFAA0FyD,WAA1F,qBAAf;AACA,QAAME,IAAI,GAAG,IAAInE,IAAI,CAACW,SAAT,CAAmBuD,MAAnB,CAAb;AACA,QAAME,SAAS,GAAGD,IAAI,CAACE,oBAAL,CAA0B,WAA1B,CAAlB;AAEArE,IAAAA,IAAI,CAACsE,eAAL,CAAqBC,QAArB,CAA8BR,GAA9B,EAAmC,IAAI/D,IAAI,CAACwE,QAAT,CAAkBJ,SAAlB,CAAnC;AACD,GARD;AASD;;AAEDR,iBAAiB;AAEjBa,MAAM,CAACC,OAAP,GAAiBvE,YAAjB","sourcesContent":["'use strict';\n\nconst ICAL = require('ical.js');\n\n// Copied from https://dxr.mozilla.org/comm-central/source/calendar/timezones/zones.json\n// And compiled using node compile-zones.js\n// See also https://github.com/mozilla-comm/ical.js/issues/195\nconst timezones = require('./zones-compiled.json');\n\nclass IcalExpander {\n  constructor(opts) {\n    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1000;\n    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;\n\n    this.jCalData = ICAL.parse(opts.ics);\n    this.component = new ICAL.Component(this.jCalData);\n    this.events = this.component.getAllSubcomponents('vevent').map(vevent => new ICAL.Event(vevent));\n\n    if (this.skipInvalidDates) {\n      this.events = this.events.filter((evt) => {\n        try {\n          evt.startDate.toJSDate();\n          evt.endDate.toJSDate();\n          return true;\n        } catch (err) {\n          // skipping events with invalid time\n          return false;\n        }\n      });\n    }\n  }\n\n  between(after, before) {\n    function isEventWithinRange(startTime, endTime) {\n      return (!after || endTime >= after.getTime()) &&\n      (!before || startTime <= before.getTime());\n    }\n\n    function getTimes(eventOrOccurrence) {\n      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();\n      let endTime = eventOrOccurrence.endDate.toJSDate().getTime();\n\n      // If it is an all day event, the end date is set to 00:00 of the next day\n      // So we need to make it be 23:59:59 to compare correctly with the given range\n      if (eventOrOccurrence.endDate.isDate && (endTime > startTime)) {\n        endTime -= 1;\n      }\n\n      return { startTime, endTime };\n    }\n\n    const exceptions = [];\n\n    this.events.forEach((event) => {\n      if (event.isRecurrenceException()) exceptions.push(event);\n    });\n\n    const ret = {\n      events: [],\n      occurrences: [],\n    };\n\n    this.events.filter(e => !e.isRecurrenceException()).forEach((event) => {\n      const exdates = [];\n\n      event.component.getAllProperties('exdate').forEach((exdateProp) => {\n        const exdate = exdateProp.getFirstValue();\n        exdates.push(exdate.toJSDate().getTime());\n      });\n\n      // Recurring event is handled differently\n      if (event.isRecurring()) {\n        const iterator = event.iterator();\n\n        let next;\n        let i = 0;\n\n        do {\n          i += 1;\n          next = iterator.next();\n          if (next) {\n            const occurrence = event.getOccurrenceDetails(next);\n\n            const { startTime, endTime } = getTimes(occurrence);\n\n            const isOccurrenceExcluded = exdates.indexOf(startTime) !== -1;\n\n            // TODO check that within same day?\n            const exception = exceptions.find(ex => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());\n\n            // We have passed the max date, stop\n            if (before && startTime > before.getTime()) break;\n\n            // Check that we are within our range\n            if (isEventWithinRange(startTime, endTime)) {\n              if (exception) {\n                ret.events.push(exception);\n              } else if (!isOccurrenceExcluded) {\n                ret.occurrences.push(occurrence);\n              }\n            }\n          }\n        }\n        while (next && (!this.maxIterations || i < this.maxIterations));\n\n        return;\n      }\n\n      // Non-recurring event:\n      const { startTime, endTime } = getTimes(event);\n\n      if (isEventWithinRange(startTime, endTime)) ret.events.push(event);\n    });\n\n    return ret;\n  }\n\n  before(before) {\n    return this.between(undefined, before);\n  }\n\n  after(after) {\n    return this.between(after);\n  }\n\n  all() {\n    return this.between();\n  }\n}\n\nfunction registerTimezones() {\n  Object.keys(timezones).forEach((key) => {\n    const icsData = timezones[key];\n    const icsTimezone = `BEGIN:VTIMEZONE\\r\\nTZID:${key}\\r\\n${icsData}\\r\\nEND:VTIMEZONE`;\n    const parsed = ICAL.parse(`BEGIN:VCALENDAR\\nPRODID:-//tzurl.org//NONSGML Olson 2012h//EN\\nVERSION:2.0\\n${icsTimezone}\\nEND:VCALENDAR`);\n    const comp = new ICAL.Component(parsed);\n    const vtimezone = comp.getFirstSubcomponent('vtimezone');\n\n    ICAL.TimezoneService.register(key, new ICAL.Timezone(vtimezone));\n  });\n}\n\nregisterTimezones();\n\nmodule.exports = IcalExpander;\n"]},"metadata":{},"sourceType":"script"}