{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar XmlNode = require('./XmlNode');\n/**\nElement in an XML document.\n\n@public\n*/\n\n\nvar XmlElement = /*#__PURE__*/function (_XmlNode) {\n  _inherits(XmlElement, _XmlNode);\n\n  var _super = _createSuper(XmlElement);\n\n  /**\n  @param {string} name\n  @param {{[attrName: string]: string}} [attributes]\n  @param {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>} [children]\n  */\n  function XmlElement(name) {\n    var _this;\n\n    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.create(null);\n    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, XmlElement);\n\n    _this = _super.call(this);\n    /**\n    Name of this element.\n     @type {string}\n    @public\n    */\n\n    _this.name = name;\n    /**\n    Attributes on this element.\n     @type {{[attrName: string]: string}}\n    @public\n    */\n\n    _this.attributes = attributes;\n    /**\n    Child nodes of this element.\n     @type {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>}\n    @public\n    */\n\n    _this.children = children;\n    return _this;\n  }\n  /**\n  Whether this node is empty (meaning it has no children).\n   @type {boolean}\n  @public\n  */\n\n\n  _createClass(XmlElement, [{\n    key: \"isEmpty\",\n    get: function get() {\n      return this.children.length === 0;\n    }\n    /** @type {boolean} */\n\n  }, {\n    key: \"preserveWhitespace\",\n    get: function get() {\n      /** @type {XmlNode?} */\n      var node = this;\n\n      while (node instanceof XmlElement) {\n        if ('xml:space' in node.attributes) {\n          return node.attributes['xml:space'] === 'preserve';\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n    Text content of this element and all its descendants.\n     @type {string}\n    @public\n    */\n\n  }, {\n    key: \"text\",\n    get: function get() {\n      return this.children.map(function (child) {\n        return 'text' in child ? child.text : '';\n      }).join('');\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return XmlNode.TYPE_ELEMENT;\n    }\n    /** @returns {{[key: string]: any}} */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign(XmlNode.prototype.toJSON.call(this), {\n        name: this.name,\n        attributes: this.attributes,\n        children: this.children.map(function (child) {\n          return child.toJSON();\n        })\n      });\n    }\n  }]);\n\n  return XmlElement;\n}(XmlNode);\n\nmodule.exports = XmlElement;\n/** @typedef {import('./XmlCdata')} XmlCdata */\n\n/** @typedef {import('./XmlComment')} XmlComment */\n\n/** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */\n\n/** @typedef {import('./XmlText')} XmlText */","map":{"version":3,"sources":["/home/rupak/Music/project_medical_pager_chat-master/client/node_modules/@rgrove/parse-xml/src/lib/XmlElement.js"],"names":["XmlNode","require","XmlElement","name","attributes","Object","create","children","length","node","parent","map","child","text","join","TYPE_ELEMENT","assign","prototype","toJSON","call","module","exports"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;;;IACMC,U;;;;;AACJ;AACF;AACA;AACA;AACA;AACE,sBAAYC,IAAZ,EAAmE;AAAA;;AAAA,QAAjDC,UAAiD,uEAApCC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAoC;AAAA,QAAfC,QAAe,uEAAJ,EAAI;;AAAA;;AACjE;AAEA;AACJ;AACA;AACA;AACA;;AAEI,UAAKJ,IAAL,GAAYA,IAAZ;AAEA;AACJ;AACA;AACA;AACA;;AAEI,UAAKC,UAAL,GAAkBA,UAAlB;AAEA;AACJ;AACA;AACA;AACA;;AAEI,UAAKG,QAAL,GAAgBA,QAAhB;AAzBiE;AA0BlE;AAED;AACF;AACA;AACA;AACA;;;;;SAEE,eAAc;AACZ,aAAO,KAAKA,QAAL,CAAcC,MAAd,KAAyB,CAAhC;AACD;AAED;;;;SACA,eAAyB;AACvB;AACA,UAAIC,IAAI,GAAG,IAAX;;AAEA,aAAOA,IAAI,YAAYP,UAAvB,EAAmC;AACjC,YAAI,eAAeO,IAAI,CAACL,UAAxB,EAAoC;AAClC,iBAAOK,IAAI,CAACL,UAAL,CAAgB,WAAhB,MAAiC,UAAxC;AACD;;AAEDK,QAAAA,IAAI,GAAGA,IAAI,CAACC,MAAZ;AACD;;AAED,aAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;SAEE,eAAW;AACT,aAAO,KAAKH,QAAL,CACJI,GADI,CACA,UAAAC,KAAK;AAAA,eAAI,UAAUA,KAAV,GAAkBA,KAAK,CAACC,IAAxB,GAA+B,EAAnC;AAAA,OADL,EAEJC,IAFI,CAEC,EAFD,CAAP;AAGD;;;SAED,eAAW;AACT,aAAOd,OAAO,CAACe,YAAf;AACD;AAED;;;;WACA,kBAAS;AACP,aAAOV,MAAM,CAACW,MAAP,CAAchB,OAAO,CAACiB,SAAR,CAAkBC,MAAlB,CAAyBC,IAAzB,CAA8B,IAA9B,CAAd,EAAmD;AACxDhB,QAAAA,IAAI,EAAE,KAAKA,IAD6C;AAExDC,QAAAA,UAAU,EAAE,KAAKA,UAFuC;AAGxDG,QAAAA,QAAQ,EAAE,KAAKA,QAAL,CAAcI,GAAd,CAAkB,UAAAC,KAAK;AAAA,iBAAIA,KAAK,CAACM,MAAN,EAAJ;AAAA,SAAvB;AAH8C,OAAnD,CAAP;AAKD;;;;EAnFsBlB,O;;AAsFzBoB,MAAM,CAACC,OAAP,GAAiBnB,UAAjB;AAEA;;AACA;;AACA;;AACA","sourcesContent":["'use strict';\n\nconst XmlNode = require('./XmlNode');\n\n/**\nElement in an XML document.\n\n@public\n*/\nclass XmlElement extends XmlNode {\n  /**\n  @param {string} name\n  @param {{[attrName: string]: string}} [attributes]\n  @param {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>} [children]\n  */\n  constructor(name, attributes = Object.create(null), children = []) {\n    super();\n\n    /**\n    Name of this element.\n\n    @type {string}\n    @public\n    */\n    this.name = name;\n\n    /**\n    Attributes on this element.\n\n    @type {{[attrName: string]: string}}\n    @public\n    */\n    this.attributes = attributes;\n\n    /**\n    Child nodes of this element.\n\n    @type {Array<XmlCdata|XmlComment|XmlElement|XmlProcessingInstruction|XmlText>}\n    @public\n    */\n    this.children = children;\n  }\n\n  /**\n  Whether this node is empty (meaning it has no children).\n\n  @type {boolean}\n  @public\n  */\n  get isEmpty() {\n    return this.children.length === 0;\n  }\n\n  /** @type {boolean} */\n  get preserveWhitespace() {\n    /** @type {XmlNode?} */\n    let node = this;\n\n    while (node instanceof XmlElement) {\n      if ('xml:space' in node.attributes) {\n        return node.attributes['xml:space'] === 'preserve';\n      }\n\n      node = node.parent;\n    }\n\n    return false;\n  }\n\n  /**\n  Text content of this element and all its descendants.\n\n  @type {string}\n  @public\n  */\n  get text() {\n    return this.children\n      .map(child => 'text' in child ? child.text : '')\n      .join('');\n  }\n\n  get type() {\n    return XmlNode.TYPE_ELEMENT;\n  }\n\n  /** @returns {{[key: string]: any}} */\n  toJSON() {\n    return Object.assign(XmlNode.prototype.toJSON.call(this), {\n      name: this.name,\n      attributes: this.attributes,\n      children: this.children.map(child => child.toJSON()),\n    });\n  }\n}\n\nmodule.exports = XmlElement;\n\n/** @typedef {import('./XmlCdata')} XmlCdata */\n/** @typedef {import('./XmlComment')} XmlComment */\n/** @typedef {import('./XmlProcessingInstruction')} XmlProcessingInstruction */\n/** @typedef {import('./XmlText')} XmlText */\n"]},"metadata":{},"sourceType":"script"}