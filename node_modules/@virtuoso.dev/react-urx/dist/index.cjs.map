{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * `@virtuoso.dev/react-urx` exports the [[systemToComponent]] function.\n * It wraps urx systems in to UI **logic provider components**,\n * mapping the system input and output streams to the component input / output points.\n *\n * ### Simple System wrapped as React Component\n *\n * ```tsx\n * const sys = system(() => {\n *   const foo = statefulStream(42)\n *   return { foo }\n * })\n *\n * const { Component: MyComponent, useEmitterValue } = systemToComponent(sys, {\n *   required: { fooProp: 'foo' },\n * })\n *\n * const Child = () => {\n *   const foo = useEmitterValue('foo')\n *   return <div>{foo}</div>\n * }\n *\n * const App = () => {\n *   return <Comp fooProp={42}><Child /><Comp>\n * }\n * ```\n *\n * @packageDocumentation\n */\nimport * as React from 'react'\nimport {\n  ComponentType,\n  createContext,\n  createElement,\n  forwardRef,\n  ForwardRefExoticComponent,\n  ReactNode,\n  RefAttributes,\n  useContext,\n  useImperativeHandle,\n  useState,\n  useCallback,\n} from 'react'\nimport {\n  AnySystemSpec,\n  reset,\n  curry1to0,\n  curry2to1,\n  Emitter,\n  SR,\n  eventHandler,\n  getValue,\n  publish,\n  Publisher,\n  init,\n  StatefulStream,\n  Stream,\n  subscribe,\n  always,\n  tap,\n} from '@virtuoso.dev/urx'\n\n/** @internal */\ninterface Dict<T> {\n  [key: string]: T\n}\n\n/** @internal */\nfunction omit<O extends Dict<any>, K extends readonly string[]>(keys: K, obj: O): Omit<O, K[number]> {\n  const result: Dict<any> = {}\n  const index: Dict<1> = {}\n  let idx = 0\n  const len = keys.length\n\n  while (idx < len) {\n    index[keys[idx]] = 1\n    idx += 1\n  }\n\n  for (const prop in obj) {\n    if (!Object.prototype.hasOwnProperty.call(index, prop)) {\n      result[prop] = obj[prop]\n    }\n  }\n\n  return result as any\n}\n\nconst useIsomorphicLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\n/** @internal */\nexport type Observable<T> = Emitter<T> | Publisher<T>\n\n/**\n * Describes the mapping between the system streams and the component properties.\n * Each property uses the keys as the names of the properties and the values as the corresponding stream names.\n * @typeParam SS the type of the system.\n */\nexport interface SystemPropsMap<SS extends AnySystemSpec, K = keyof SR<SS>, D = { [key: string]: K }> {\n  /**\n   * Specifies the required component properties.\n   */\n  required?: D\n  /**\n   * Specifies the optional component properties.\n   */\n  optional?: D\n  /**\n   * Specifies the component methods, if any. Streams are converted to methods with a single argument.\n   * When invoked, the method publishes the value of the argument to the specified stream.\n   */\n  methods?: D\n  /**\n   * Specifies the component \"event\" properties, if any.\n   * Event properties accept callback functions which get executed when the stream emits a new value.\n   */\n  events?: D\n}\n\n/** @internal */\nexport type PropsFromPropMap<E extends AnySystemSpec, M extends SystemPropsMap<E>> = {\n  [K in Extract<keyof M['required'], string>]: M['required'][K] extends string\n    ? SR<E>[M['required'][K]] extends Observable<infer R>\n      ? R\n      : never\n    : never\n} &\n  {\n    [K in Extract<keyof M['optional'], string>]?: M['optional'][K] extends string\n      ? SR<E>[M['optional'][K]] extends Observable<infer R>\n        ? R\n        : never\n      : never\n  } &\n  {\n    [K in Extract<keyof M['events'], string>]?: M['events'][K] extends string\n      ? SR<E>[M['events'][K]] extends Observable<infer R>\n        ? (value: R) => void\n        : never\n      : never\n  }\n\n/** @internal */\nexport type MethodsFromPropMap<E extends AnySystemSpec, M extends SystemPropsMap<E>> = {\n  [K in Extract<keyof M['methods'], string>]: M['methods'][K] extends string\n    ? SR<E>[M['methods'][K]] extends Observable<infer R>\n      ? (value: R) => void\n      : never\n    : never\n}\n\n/**\n * Used to correctly specify type refs for system components\n *\n * ```tsx\n * const s = system(() => { return { a: statefulStream(0) } })\n * const { Component } = systemToComponent(s)\n *\n * const App = () => {\n *  const ref = useRef<RefHandle<typeof Component>>()\n *  return <Component ref={ref} />\n * }\n * ```\n *\n * @typeParam T the type of the component\n */\nexport type RefHandle<T> = T extends ForwardRefExoticComponent<RefAttributes<infer Handle>> ? Handle : never\n\n/**\n * Converts a system spec to React component by mapping the system streams to component properties, events and methods. Returns hooks for querying and modifying\n * the system streams from the component's child components.\n * @param systemSpec The return value from a [[system]] call.\n * @param map The streams to props / events / methods mapping Check [[SystemPropsMap]] for more details.\n * @param Root The optional React component to render. By default, the resulting component renders nothing, acting as a logical wrapper for its children.\n * @returns an object containing the following:\n *  - `Component`: the React component.\n *  - `useEmitterValue`: a hook that lets child components use values emitted from the specified output stream.\n *  - `useEmitter`: a hook that calls the provided callback whenever the specified stream emits a value.\n *  - `usePublisher`: a hook which lets child components publish values to the specified stream.\n *  <hr />\n */\nexport function systemToComponent<SS extends AnySystemSpec, M extends SystemPropsMap<SS>, S extends SR<SS>, R>(\n  systemSpec: SS,\n  map: M,\n  Root?: R\n) {\n  const requiredPropNames = Object.keys(map.required ?? {})\n  const optionalPropNames = Object.keys(map.optional ?? {})\n  const methodNames = Object.keys(map.methods ?? {})\n  const eventNames = Object.keys(map.events ?? {})\n  const Context = createContext<SR<SS>>(({} as unknown) as any)\n\n  type RootCompProps = R extends ComponentType<infer RP> ? RP : { children?: ReactNode }\n\n  type CompProps = PropsFromPropMap<SS, M> & RootCompProps\n\n  type CompMethods = MethodsFromPropMap<SS, M>\n\n  function applyPropsToSystem(system: ReturnType<SS['constructor']>, props: any) {\n    if (system.propsReady !== undefined) {\n      publish(system.propsReady, false)\n    }\n\n    for (let index = 0; index < requiredPropNames.length; index++) {\n      const requiredPropName = requiredPropNames[index]\n      const stream = system[map.required![requiredPropName]]\n      publish(stream, props[requiredPropName])\n    }\n\n    for (let index = 0; index < optionalPropNames.length; index++) {\n      const optionalPropName = optionalPropNames[index]\n      if (optionalPropName in props) {\n        const stream = system[map.optional![optionalPropName]]\n        publish(stream, props[optionalPropName])\n      }\n    }\n\n    if (system.propsReady !== undefined) {\n      publish(system.propsReady, true)\n    }\n  }\n\n  function buildMethods(system: ReturnType<SS['constructor']>) {\n    return methodNames.reduce((acc, methodName) => {\n      ;(acc as any)[methodName] = (value: any) => {\n        const stream = system[map.methods![methodName]]\n        publish(stream, value)\n      }\n      return acc\n      // eslint-disable-next-line\n    }, {} as CompMethods)\n  }\n\n  function buildEventHandlers(system: ReturnType<SS['constructor']>) {\n    return eventNames.reduce<{ [key: string]: Emitter<any> }>((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system[map.events![eventName]])\n      return handlers\n    }, {})\n  }\n\n  /**\n   * A React component generated from an urx system\n   */\n  const Component = forwardRef<CompMethods, CompProps>((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren as any\n\n    const [system] = useState(() => {\n      return tap(init(systemSpec), system => applyPropsToSystem(system, props))\n    })\n\n    const [handlers] = useState(curry1to0(buildEventHandlers, system))\n\n    useIsomorphicLayoutEffect(() => {\n      for (let index = 0; index < eventNames.length; index++) {\n        const eventName = eventNames[index]\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName])\n        }\n      }\n\n      return () => {\n        Object.values(handlers).map(reset)\n      }\n    }, [props, handlers, system])\n\n    useIsomorphicLayoutEffect(() => {\n      applyPropsToSystem(system, props)\n    })\n\n    useImperativeHandle(ref, always(buildMethods(system)))\n\n    return createElement(\n      Context.Provider,\n      { value: system },\n      Root !== undefined\n        ? createElement(\n            (Root as unknown) as ComponentType,\n            omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n            children\n          )\n        : children\n    )\n  })\n\n  const usePublisher = <K extends keyof S>(key: K) => {\n    return useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]) as (\n      value: S[K] extends Stream<infer R> ? R : never\n    ) => void\n  }\n\n  /**\n   * Returns the value emitted from the stream.\n   */\n  const useEmitterValue = <K extends keyof S, V = S[K] extends StatefulStream<infer R> ? R : never>(key: K) => {\n    const context = useContext(Context)\n    const source: StatefulStream<V> = context[key]\n\n    const [value, setValue] = useState(curry1to0(getValue, source))\n\n    useIsomorphicLayoutEffect(\n      () =>\n        subscribe(source, (next: V) => {\n          if (next !== value) {\n            setValue(always(next))\n          }\n        }),\n      [source, value]\n    )\n\n    return value\n  }\n\n  const useEmitter = <K extends keyof S, V = S[K] extends Stream<infer R> ? R : never>(key: K, callback: (value: V) => void) => {\n    const context = useContext(Context)\n    const source: Stream<V> = context[key]\n    useIsomorphicLayoutEffect(() => subscribe(source, callback), [callback, source])\n  }\n\n  return {\n    Component,\n    usePublisher,\n    useEmitterValue,\n    useEmitter,\n  }\n}\n"],"names":["useIsomorphicLayoutEffect","document","React","useLayoutEffect","useEffect","systemSpec","map","Root","requiredPropNames","Object","keys","required","optionalPropNames","optional","methodNames","methods","eventNames","events","Context","createContext","applyPropsToSystem","system","props","undefined","propsReady","publish","index","length","requiredPropName","optionalPropName","buildEventHandlers","reduce","handlers","eventName","eventHandler","Component","forwardRef","propsWithChildren","ref","children","useState","tap","init","curry1to0","subscribe","values","reset","useImperativeHandle","always","acc","methodName","value","buildMethods","createElement","Provider","obj","result","idx","len","prop","prototype","hasOwnProperty","call","omit","usePublisher","key","useCallback","curry2to1","useContext","useEmitterValue","source","getValue","setValue","next","useEmitter","callback"],"mappings":"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"}